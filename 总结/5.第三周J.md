# 第三周

## 二十二.正则表达式

> regular expression : RegExp
>
> 用来处理字符串的规则
>
> - 只能处理字符串
> - 它是一个规则：可以验证字符串是否符合某个规则（test），也可以把字符串符中符合规则的内容捕获到（ exec / match... ）

~~~js
let str = "good good study , day day up!";
//=>学正则就是用来制定规则（是否包含数字）
let reg = /\d+/;
reg.test(str); //=>false

str = "2019-08-12";
reg.esec(str); //=>["2019",index:0,inputs:"原始字符串"]
~~~

### 编写正则表达式

#### 创建的方式有两种

~~~js
//=>字面量创建方式（两个斜杠之间包起来的，都是用来描述规则的元字符）
let reg1 = /\d+/;

//=>构造函数模式创建  两个参数：元字符字符串，修饰符字符串
let reg2 = new RegExp("\\d+");
~~~

#### 正则表达式由两部分组成

- 元字符
- 修饰符

**元字符**

~~~js
/*常用的元字符*/
//=>1.量词元字符：设置出现的次数
* 零到多次  
+ 一到多次
? 零次或者一次
{n} 出现n次
{n,} 出现n到多次
{n,m} 出现n到m次

//=>2.特殊元字符：单个或者组合在一起代表特殊的含义
\    转义字符（普通->特殊->普通）
.    除\n（换行符）以外的任意字符
^    以哪一个元字符作为开始
$    以哪一个元字符作为结束
\n   换行符
\d   0~9之间的一个数字
\D   非0~9之间的一个数字 （大写和小写的意思是相反的）
\w   数字、字母、下划线中的任意一个字符
\s   一个空白字符（包含空格、制表符、换页符等）
\t   一个制表符（一个TAB键：四个空格）
\b   匹配一个单词的边界
x|y  x或者y中的一个字符
[xyz] x或者y或者z中的一个字符
[^xy] 除了x/y以外的任意字符
[a-z] 指定a-z这个范围中的任意字符  [0-9a-zA-Z_]===\w
[^a-z] 上一个的取反“非”
()   正则中的分组符号
(?:) 只匹配不捕获
(?=) 正向预查
(?!) 负向预查 

//=>3.普通元字符：代表本身含义的
/yuanzhi/ 此正则匹配的就是 "yuanzhi"
~~~

**修饰符**

~~~js
/*正则表达式常用的修饰符：img*/
i =>ignoreCase  忽略单词大小写匹配
m =>multiline   可以进行多行匹配
g =>global      全局匹配

/* 
/A/.test('lalala')  =>false
/A/i.test('lalala') =>true
*/
~~~

### 元字符详细解析

`^ $`

```javascript
let reg = /^\d/;
console.log(reg.test("yuanzhi")); //=>false
console.log(reg.test("2019yuanzhi"));//=>true
console.log(reg.test("yuanzhi2019"));//=>false
```

```javascript
let reg = /\d$/;
console.log(reg.test("yuanzhi")); //=>false
console.log(reg.test("2019yuanzhi"));//=>false
console.log(reg.test("yuanzhi2019"));//=>true
```

```javascript
//=>^/$两个都不加：字符串中包含符合规则的内容即可
let reg1 = /\d+/;
//=>^/$两个都加：字符串只能是和规则一致的内容
let reg2 = /^\d+$/;

//=>举个例子：验证手机号码（11位，第一个数字是1即可）
let reg = /^1\d{10}$/;
```

`\`

```javascript
//=>.不是小数点，是除\n外的任意字符
let reg = /^2.3$/;
console.log(reg.test("2.3"));//=>true
console.log(reg.test("2@3"));//=>true
console.log(reg.test("23"));//=>false

//=>基于转义字符，让其只能代表小数点
reg = /^2\.3$/;
console.log(reg.test("2.3"));//=>true
console.log(reg.test("2@3"));//=>false

let str = "\\d";
reg = /^\d$/; //=>\d代表0-9的数字
console.log(reg.test(str)); //=>false
reg = /^\\d$/; //=>把特殊符合转换为普通的
console.log(reg.test(str)); //=>true
```

`x|y`

```javascript
let reg = /^18|29$/;
console.log(reg.test("18")); //=>true
console.log(reg.test("29")); //=>true
console.log(reg.test("129")); //=>true
console.log(reg.test("189")); //=>true
console.log(reg.test("1829")); //=>true
console.log(reg.test("829")); //=>true
console.log(reg.test("182")); //=>true
//---直接x|y会存在很乱的优先级问题，一般我们写的时候都伴随着小括号进行分组，因为小括号改变处理的优先级 =>小括号：分组
reg = /^(18|29)$/;
console.log(reg.test("18")); //=>true
console.log(reg.test("29")); //=>true
console.log(reg.test("129")); //=>false
console.log(reg.test("189")); //=>false
//=>只能是18或者29中的一个了
```

`[]`

```javascript
//1.中括号中出现的字符一般都代表本身的含义
let reg = /^[@+]$/;
console.log(reg.test("@")); //=>true
console.log(reg.test("+")); //=>true
console.log(reg.test("@@")); //=>false
console.log(reg.test("@+")); //=>false

reg = /^[\d]$/; //=>\d在中括号中还是0-9
console.log(reg.test("d"));//=>false
console.log(reg.test("\\"));//=>false
console.log(reg.test("9"));//=>true

//2.中括号中不存在多位数
reg = /^[18]$/;
console.log(reg.test("1")); //=>true
console.log(reg.test("8")); //=>true
console.log(reg.test("18")); //=>false

reg = /^[10-29]$/; //=>1或者0-2或者9
console.log(reg.test("1"));//=>true
console.log(reg.test("9"));//=>true
console.log(reg.test("0"));//=>true
console.log(reg.test("2"));//=>true
console.log(reg.test("10"));//=>false
```

### 常用的正则表达式

**1.验证是否为有效数字**

~~~js
/*
 * 规则分析
 * 1.可能出现 + - 号，也可能不出现  [+-]?
 * 2.一位0-9都可以，多位首位不能是0 (\d|([1-9]\d+))
 * 3.小数部分可能有可能没有，一旦有后面必须有小数点+数字 (\.\d+)?
 */
let reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;
~~~

**2.验证密码**

~~~js
//=>数字、字母、下划线
//=>6~16位
let val = userPassInp.value,
    reg = /^\w{6,16}$/;
let flag=reg.test(val);
/*
function checkPass(val){
    if(val.length<6 || val.length>16){
    	alert('长度必须介于6-16位之间！');
    	return;
	}
    let area=['a','b'....'_']; //=>包含数字、字母、下划线
    for(let i=0;i<val.length;i++){
        let char=val[i];
        if(!area.includes(char)){
            alert('格式不正确！');
    		return;
        }
    }
}
*/
~~~

**3.验证真实姓名的**

~~~js
/*
 * 1.汉字  /^[\u4E00-\u9FA5]$/
 * 2.名字长度 2~10位
 * 3.可能有译名 ·汉字  (·[\u4E00-\u9FA5]{2,10}){0,2}
 */
let reg = /^[\u4E00-\u9FA5]{2,10}(·[\u4E00-\u9FA5]{2,10}){0,2}$/;
~~~

**4.验证邮箱的**

~~~js
let reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/;

//=> \w+((-\w+)|(\.\w+))*
//1.开头是数字字母下划线（1到多位）
//2.还可以是 -数字字母下划线 或者 .数字字母下划线,整体零到多次
//=>邮箱的名字由“数字、字母、下划线、-、.”几部分组成，但是-/.不能连续出现也不能作为开始

//=> @[A-Za-z0-9]+
//1.@后面紧跟着：数字、字母 （1-多位）

//=> ((\.|-)[A-Za-z0-9]+)*
//1.对@后面名字的补充
// 多域名     .com.cn
// 企业邮箱    wxy@yuanzhi-lilan-office.com

//=> \.[A-Za-z0-9]+
//1. 这个匹配的是最后的域名（.com/.cn/.org/.edu/.net...）
~~~

**5.身份证号码**

~~~js
/*
 * 1. 一共18位
 * 2. 最后一位可能是X
 *
 * 身份证前六位：省市县  130828
 * 中间八位：年月日
 * 最后四位：
 *   最后一位 => X或者数字
 *   倒数第二位 => 偶数 女  奇数 男
 *   其余的是经过算法算出来的
 */
//let reg = /^\d{17}(\d|X)$/;
//=>小括号分组的第二个作用：分组捕获，不仅可以把大正则匹配的信息捕获到，还可以单独捕获到每个小分组的内容
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/;
reg.exec("130828199012040617"); //=>["130828199012040617", "130828", "1990", "12", "04", "1", "7"...] 捕获结果是数组，包含每一个小分组单独获取的内容
~~~

### 正则两种创建方式的区别

```js
//=>构造函数因为传递的是字符串，\需要写两个才代表斜杠
let reg = /\d+/g;
reg = new RegExp("\\d+","g");

//=>正则表达是中的部分内容是变量存储的值
//1.两个斜杠中间包起来的都是元字符（如果正则中要包含某个变量的值，则不能使用字面量方式创建）
let type = "yuanzhi";
reg = /^@"+type+"@$/; 
console.log(reg.test("@yuanzhi@")); //=>false
console.log(reg.test('@"""typeeeee"@')); //=>true
//2.这种情况只能使用构造函数方式（因为它传递的规则是字符串，只有这样才能进行字符串拼接）
reg = new RegExp("^@"+type+"@$");
console.log(reg.test("@yuanzhi@"));//=>true
```

### 正则捕获

> 实现正则捕获的办法
>
> - 正则RegExp.prototype上的方法
>   - exec
>   - test
> - 字符串String.prototype上支持正则表达式处理的方法
>   - replace
>   - match
>   - splite
>   - ......

~~~js
let str = "yuanzhi2019yangfan2020qihang2021";
let reg = /\d+/;
/*
 * 基于exec实现正则的捕获
 *   1.捕获到的结果是null或者一个数组
 *     第一项：本次捕获到的内容
 *     其余项：对应小分组本次单独捕获的内容
 *     index：当前捕获内容在字符串中的起始索引
 *     input：原始字符串
 *   2.每执行一次exec，只能捕获到一个符合正则规则的，但是默认情况下，我们执行一百遍，获取的结果永远都是第一个匹配到的，其余的捕获不到
 *     =>“正则捕获的懒惰性”：默认只捕获第一个
 */
console.log(reg.exec(str)); //=>["2019", index: 7, input: "yuanzhi2019yangfan2020qihang2021"]
console.log(reg.exec(str)); //=>["2019"...]

/*
//=>实现正则捕获的前提是：当前正则要和字符串匹配，如果不匹配捕获的结果是null
let reg = /^\d+$/;
console.log(reg.test(str)); //=>false
console.log(reg.exec(str)); //=>null
*/
~~~

#### 懒惰性的解决办法

~~~js
let str = "yuanzhi2019yangfan2020qihang2021";
		/*
		 * reg.lastIndex：当前正则下一次匹配的起始索引位置 
		 *   懒惰性捕获的原因：默认情况下lastIndex的值不会被修改，每一次都是从字符串开始位置查找，所以找到的永远只是第一个
		 *   解决办法：全局修饰符g
		 */
		// let reg = /\d+/;
		// console.log(reg.lastIndex); //=>0 下面匹配捕获是从STR索引零的位置开始找
		// console.log(reg.exec(str));
		// console.log(reg.lastIndex); //=>0 第一次匹配捕获完成，lastIndex没有改变，所以下一次exec依然是从字符串最开始找，找到的永远是第一个匹配到的

		// let reg = /\d+/g;
		// console.log(reg.exec(str)); //=>["2019"...]
		// console.log(reg.lastIndex); //=>11 设置全局匹配修饰符g后，第一次匹配完，lastIndex会自己修改
		// console.log(reg.exec(str)); //=>["2020"...]
		// console.log(reg.lastIndex); //=>22
		// console.log(reg.exec(str)); //=>["2021"...]
		// console.log(reg.lastIndex); //=>32
		// console.log(reg.exec(str)); //=>null 当全部捕获后，再次捕获的结果是null，但是lastIndex又回归了初始值零，再次捕获又从第一个开始了...
		// console.log(reg.lastIndex); //=>0
		// console.log(reg.exec(str)); //=>["2019"...]

		// let reg = /\d+/g;
		// if (reg.test(str)) {
		// 	//=>验证一下:只有正则和字符串匹配我们在捕获
		// 	console.log(reg.lastIndex); //=>11 基于TEST匹配验证后，LASTINDEX已经被修改为第一次匹配后的结果，所以下一次捕获不再从头开始了
		// 	console.log(reg.exec(str)); //=>["2020"...]
		// }

		//=>需求：编写一个方法execAll，执行一次可以把所有匹配的结果捕获到（前提正则一定要设置全局修饰符g）
		~ function () {
			function execAll(str = "") {
				//=>str:要匹配的字符串
				//=>this:RegExp的实例（当前操作的正则）
				//=>进来后的第一件事，是验证当前正则是否设置了G，不设置则不能在进行循环捕获了，否则会导致死循环
				if (!this.global) return this.exec(str);
				//=>ARY存储最后所有捕获的信息  RES存储每一次捕获的内容（数组）
				let ary = [],
					res = this.exec(str);
				while (res) {
					//=>把每一次捕获的内容RES[0]存放到数组中
					ary.push(res[0]);
					//=>只要捕获的内容不为NULL，则继续捕获下去
					res = this.exec(str);
				}
				return ary.length === 0 ? null : ary;
			}
			RegExp.prototype.execAll = execAll;
		}();

		let reg = /\d+/g;
		console.log(reg.execAll("沅芷2019@2020澧兰"));
		//=>字符串中的MATCH方法，可以在执行一次的情况下，捕获到所有匹配的数据（前提：正则也得设置G才可以）
		console.log("沅芷2019@2020澧兰".match(reg));
~~~

#### 正则的分组捕获

~~~js
//=>身份证号码
let str = "130828199012040112";
let reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(?:\d|X)$/;
console.log(reg.exec(str));
console.log(str.match(reg));
//=>["130828199012040112", "130828", "1990", "12", "04", "1", index: 0, input: "130828199012040112"]
//=>第一项：大正则匹配的结果
//=>其余项：每一个小分组单独匹配捕获的结果
//=>如果设置了分组（改变优先级），但是捕获的时候不需要单独捕获，可以基于?:来处理
~~~

~~~js
//=>既要捕获到{数字}，也想单独的把数字也获取到，例如：第一次找到 {0} 还需要单独获取0
let str = "{0}年{1}月{2}日";

/*
//=>不设置g只匹配一次，exec和match获取的结果一致（既有大正则匹配的信息，也有小分组匹配的信息）
let reg = /\{(\d+)\}/;
console.log(reg.exec(str));
console.log(str.match(reg));
//["{0}", "0",...]
*/

let reg = /\{(\d+)\}/g;
//console.log(str.match(reg)); //=>["{0}", "{1}", "{2}"] 多次匹配的情况下,match只能把大正则匹配的内容获取到，小分组匹配的信息无法获取
let aryBig=[],
    arySmall=[],
    res=reg.exec(str);
while(res){
    let [big,small]=res;
    aryBig.push(big);
    arySmall.push(small);
    res=reg.exec(str);
}
console.log(aryBig,arySmall); //=>["{0}", "{1}", "{2}"] ["0", "1", "2"]
~~~

~~~js
//=>分组的第三个作用：“分组引用”
let str = "book"; //=>"good"、"look"、"moon"、"foot"...
let reg = /^[a-zA-Z]([a-zA-Z])\1[a-zA-Z]$/; //=>分组引用就是通过“\数字”让其代表和对应分组出现一模一样的内容
console.log(reg.test("book")); //=>true
console.log(reg.test("deep")); //=>true
console.log(reg.test("some")); //=>false
~~~

#### 正则捕获的贪婪性

~~~js
let str = "沅芷2019@2020澧兰";
//=>正则捕获的贪婪性：默认情况下，正则捕获的时候，是按照当前正则所匹配的最长结果来获取的
let reg = /\d+/g;
console.log(str.match(reg)); //=>["2019","2020"]

//=>在量词元字符后面设置?：取消捕获时候的贪婪性（按照正则匹配的最短结果来获取）
reg = /\d+?/g;
console.log(str.match(reg)); //=>["2", "0", "1", "9", "2", "0", "2", "0"]
~~~

#### 问号在正则中的五大作用：

- 问号左边是非量词元字符：本身代表量词元字符，出现零到一次
- 问号左边是量词元字符：取消捕获时候的贪婪性
- (?:) 只匹配不捕获
- (?=) 正向预查
- (?!) 负向预查

#### 其它正则捕获的方法

##### 1.test也能捕获（本意是匹配）

~~~js
let str = "{0}年{1}月{2}日";
let reg = /\{(\d+)\}/g;
console.log(reg.test(str)); //=>true
console.log(RegExp.$1); //=>"0"

console.log(reg.test(str)); //=>true
console.log(RegExp.$1); //=>"1"

console.log(reg.test(str)); //=>true
console.log(RegExp.$1); //=>"2"

console.log(reg.test(str)); //=>false
console.log(RegExp.$1); //=>"2" 存储的是上次捕获的结果

//=>RegExp.$1~RegExp.$9：获取当前本次正则匹配后，第一个到第九个分组的信息
~~~

##### 2.replace字符串中实现替换的方法（一般都是伴随正则一起使用的）

~~~js
let str = "yuanzhi@2019|yuanzhi@2020";
//=>把"yuanzhi"替换成"沅芷"
//1.不用正则，执行一次只能替换一个
/*
str = str.replace("yuanzhi","沅芷").replace("yuanzhi","沅芷");
console.log(str);
*/
//2.使用正则会简单一点
str = str.replace(/yuanzhi/g,"沅芷");
console.log(str);
~~~

~~~js
let str = "yuanzhi@2019|yuanzhi@2020";
//=>把"yuanzhi"替换为"yuanzhililan"
//str=str.replace("yuanzhi","yuanzhililan").replace("yuanzhi","yuanzhililan");
//"yuanzhililanlilan@2019|yuanzhi@2020" 每一次替换都是从字符串第一个位置开始找的（类似于正则捕获的懒惰性）

//=>基于正则g可以实现
str = str.replace(/yuanzhi/g,"yuanzhililan");
~~~

**案例：把时间字符串进行处理**

~~~js
let time = "2019-08-13";
//=>变为"2019年08月13日"
let reg = /^(\d{4})-(\d{1,2})-(\d{1,2})$/;

//=>这样可以实现
//time = time.replace(reg,"$1年$2月$3日");
//console.log(time); //=>2019年08月13日

//=>还可以这样处理 [str].replace([reg],[function])
//1.首先拿REG和TIME进行匹配捕获，能匹配到几次就会把传递的函数执行几次（而且是匹配一次就执行一次）
//2.不仅把方法执行，而且REPLACE还给方法传递了实参信息（和exec捕获的内容一致的信息：大正则匹配的内容，小分组匹配的信息....）
//3.在函数中我们返回的是啥，就把当前大正则匹配的内容替换成啥
/*
time = time.replace(reg,(big,$1,$2,$3)=>{
    //=>这里的$1~$3是我们自己设置的变量
    console.log(big,$1,$2,$3);
});
*/
time = time.replace(reg,(...arg)=>{
    let [,$1,$2,$3]=arg;
    $2.length<2?$2="0"+$2:null;
    $3.length<2?$3="0"+$3:null;
    return $1+"年"+$2+"月"+$3+"日";
});
~~~

**案例：单词首字母大写**

~~~js
let str = "good good study，day day up！";
let reg = /\b([a-zA-Z])[a-zA-Z]*\b/g;
//=>函数被执行了六次，每一次都把正则匹配信息传递给函数
//=>每一次ARG:["good","g"] ["good","g"] ["study","s"]...
str = str.replace(reg,(...arg)=>{
    let [content,$1]=arg;
    $1=$1.toUpperCase();
    content=content.substring(1);
    return $1+content;
});
console.log(str); //=>"Good Good Study，Day Day Up！"
~~~

### 正则表达式的应用

#### 正则表达式之验证一个字符串中哪个字母出现的次数最多，多少次？

~~~javascript
/*==去重思维==*/
let str = "yuanzhililanjavascript";
let obj = {};
[].forEach.call(str, char => {
	if (typeof obj[char] !== "undefined") {
		obj[char]++;
		return;
	}
	obj[char] = 1;
});
let max = 1,
	res = [];
for (let key in obj) {
	let item = obj[key];
	item > max ? max = item : null;
}
for (let key in obj) {
	let item = obj[key];
	if (item === max) {
		res.push(key);
	}
}
console.log(`出现次数最多的字符是：${res}，出现了${max}次`);


/*==排序==*/
let str = "yuanzhililanjavascript";
str = str.split('').sort((a, b) => a.localeCompare(b)).join('');
// console.log(str);//=>"aaaachiiijllnnprstuvyz"
let ary = str.match(/([a-zA-Z])\1+/g).sort((a, b) => b.length - a.length);
// console.log(ary); //=>["aaaa", "iii", "ll", "nn"]
let max = ary[0].length,
	res = [ary[0].substr(0, 1)];
for (let i = 1; i < ary.length; i++) {
	let item = ary[i];
	if (item.length < max) {
		break;
	}
	res.push(item.substr(0, 1));
}
console.log(`出现次数最多的字符：${res}，出现了${max}次`);


/*==从最大到最小试着找==*/
let str = "yuanzhililanjavascript",
	max = 0,
	res = [],
	flag = false;
str = str.split('').sort((a, b) => a.localeCompare(b)).join('');
for (let i = str.length; i > 0; i--) {
	let reg = new RegExp("([a-zA-Z])\\1{" + (i - 1) + "}", "g");
	str.replace(reg, (content, $1) => {
		res.push($1);
		max = i;
		flag = true;
	});
	if (flag) break;
}
console.log(`出现次数最多的字符：${res}，出现了${max}次`);
~~~

#### 正则表达式之时间字符串格式化：formatTime

~~~js
~ function () {
	/*
	 * formatTime：时间字符串的格式化处理
	 *   @params
	 *     templete:[string] 我们最后期望获取日期格式的模板
	 *     模板规则:{0}->年  {1~5}->月日时分秒
	 *   @return
	 *     [string]格式化后的时间字符串
	 *  by yuanzhililan on 2019/08/13
	 */
	function formatTime(templete = "{0}年{1}月{2}日 {3}时{4}分{5}秒") {
		let timeAry = this.match(/\d+/g);
		return templete.replace(/\{(\d+)\}/g, (...[, $1]) => {
			let time = timeAry[$1] || "00";
			return time.length < 2 ? "0" + time : time;
		});
	}

	/* 扩展到内置类String.prototype上 */
	["formatTime"].forEach(item => {
		String.prototype[item] = eval(item);
	});
}();


let time = "2019-8-13 16:51:3";
console.log(time.formatTime());
console.log(time.formatTime("{0}年{1}月{2}日"));
console.log(time.formatTime("{1}-{2} {3}:{4}"));
time = "2019/8/13";
console.log(time.formatTime());
console.log(time.formatTime("{0}年{1}月{2}日"));
console.log(time.formatTime("{1}-{2} {3}:{4}"));


//=>服务器获取的
// "2019-8-13 16:51:3"
// "2019/8/13 16:51:3"
// "2019/8/13"
//=>想要转变为的格式
// "08月13日 16时51分"
// "2019年08月13日"
// "2019年08月13日 16时51分03秒"
~~~

#### 正则表达式之queryURLParams

~~~js
~function () {
	/* 
	 * queryURLParams：获取URL地址问号和面的参数信息（可能也包含HASH值）
	 *   @params
	 *   @return
	 *     [object]把所有问号参数信息以键值对的方式存储起来并且返回
	 * by yuanzhililan on 2019/08/13
	 */
	function queryURLParams() {
		let obj = {};
		this.replace(/([^?=&#]+)=([^?=&#]+)/g, (...[, $1, $2]) => obj[$1] = $2);
		this.replace(/#([^?=&#]+)/g, (...[, $1]) => obj['HASH'] = $1);
		return obj;
	}

	/* 扩展到内置类String.prototype上 */
	["queryURLParams"].forEach(item => {
		String.prototype[item] = eval(item);
	});
}();

let url = "http://www.yuanzhililan.cn/?lx=1&from=wx#video";
console.log(url.queryURLParams());
//=>{lx:1,from:'wx',HASH:'video'}
~~~

#### 正则表达式之千分符

~~~js
~function () {
    /* 
	 * millimeter：实现大数字的千分符处理
	 *   @params
	 *   @return
	 *     [string]千分符后的字符串
	 * by yuanzhililan on 2019/08/13
	 */
	function millimeter() {
		return this.replace(/\d{1,3}(?=(\d{3})+$)/g, content => content + ',');
	}
	
	/* 扩展到内置类String.prototype上 */
	["formatTime", "queryURLParams", "millimeter"].forEach(item => {
		String.prototype[item] = eval(item);
	});  //=>可以用forEach把多个方法扩展到内置类上
}();

let num = "15628954"; //=>"15,628,954" 千分符
console.log(num.millimeter());
num = "112345678256874"; //=>"12,345,678,256,874"
console.log(num.millimeter());

// 把字符串倒过来加
/* num = num.split('').reverse().join('');
for (let i = 2; i < num.length - 1; i += 4) {
	let prev = num.substring(0, i + 1),
		next = num.substring(i + 1);
	num = prev + "," + next;
}
num = num.split('').reverse().join('');
console.log(num); */
~~~



##  二十三.JS中DOM操作：盒子模型属性

> DOM : document object model 文档对象模型，提供系列的属性和方法，让我们能在JS中操作页面中的元素

### 获取元素的属性和方法

~~~js
document.getElementById([ID])
[context].getElementsByTagName([TAG-NAME])
[context].getElementsByClassName([CLASS-NAME]) 
//=>在IE6~8中不兼容
document.getElementsByName([NAME]) 
//=>在IE浏览器中只对表单元素的NAME有作用
[context].querySelector([SELECTOR])
[context].querySelectorAll([SELECTOR])
//=>在IE6~8中不兼容

//---------------------
document
document.documentElement  
document.head
document.body
childNodes 所有子节点
children 所有元素子节点
//=>IE6~8中会把注释节点当做元素节点获取到
parentNode
firstChild / firstElementChild
lastChild / lastElementChild
previousSibling / previousElementSibling
nextSibling / nextElementSibling
//=>所有带Element的，在IE6~8中不兼容
~~~

### DOM的增删改操作

~~~js
document.createElement([TAG-NAME])
document.createTextNode([TEXT CONTENT])
字符串拼接（模板字符串），基于innerHTML/innerText存放到容器中

[PARENT].appendChild([NEW-ELEMENT])
[PARENT].insertBefore([NEW-ELEMENT],[ELEMENT])

[ELEMENT].cloneNode([TRUE/FALSE])
[PARENT].removeChild([ELEMENT])

//=>设置自定义属性
[ELEMENT].xxx=xxx;
console.log([ELEMENT].xxx);
delete [ELEMENT].xxx;

[ELEMENT].setAttribute('xxx',xxx);
console.log([ELEMENT].getAttribute('xxx'));
[ELEMENT].removeAttribute('xxx');
~~~

### 获取元素样式和操作样式

~~~js
//=>修改元素样式
[ELEMENT].style.xxx=xxx;  //=>修改和设置它的行内样式
[ELEMENT].className=xxx;  //=>设置样式类

//=>获取元素的样式
console.log([ELEMENT].style.xxx); //=>获取的是当前元素写在行内上的样式,如果有这个样式，但是没有写在行内上，则获取不到
~~~

### JS盒子模型属性

> 基于一些属性和方法，让我满五年能够获取到当前元素的原始信息，例如：clientWidth、offsetWidth等
>
> - client
>   - width / height
>   - top / left
> - offset
>   - width / height
>   - top / left
>   - parent
> - scroll
>   - width / height
>   - top / left
>
> 方法：window.getComputedStyle([ELEMENT],[伪类]) / [ELEMENT].currentStyle

**css盒子模型**

![CSS盒子模型属性](C:\Users\左海之浅\Desktop\课程笔记\图片文件\CSS盒子模型属性.png)

**JS盒子模型属性**

![JS盒子模型属性](C:\Users\左海之浅\Desktop\课程笔记\图片文件\JS盒子模型属性.png)

~~~js
let box = document.getElementById('box');

//=>获取盒子可视区域的宽高（内容宽度+左右PADDING）
//1.内容溢出与否对他无影响
//2.获取的结果是没有单位的（其余的盒模型属性也是）
//3.获取的结果是整数，它会自己进行四舍五入（其余的盒模型属性也是）
box.clientWidth
box.clientHeight

//获取当前页面一屏幕（可视化）区域的宽高
let winW = document.documentElement.clientWidth || document.body.clientWidth;
let winH = document.documentElement.clientHeight || document.body.clientHeight;

//=>获取盒子左边框和上边框的大小
box.clientLeft
box.clientTop
~~~

~~~js
let box = document.getElementById('box');

//=>在CLIENT的基础上加上BORDER == 盒子本身的宽高
box.offsetWidth
box.offsetHeight

//=>在没有内容溢出的情况下，获取的结果和CLIENT是一样的
//=>在有内容溢出的情况下，获取的结果约等于真实内容的宽高（上/左PADDING + 真实内容的高度/宽度）
//1.不同浏览器获取的结果不尽相同
//2.设置overflow属性值对最后的结果也会产生一定的影响
box.scrollWidth
box.scrollHeight

//获取整个页面真实的高度
document.documentElement.scrollHeight || document.body.scrollHeight
~~~

~~~js
let box = document.getElementById('box');
//=>竖向滚动条卷去的高度
//=>横向滚动条卷去的宽度
//1.边界值
//min=0
//max=整个的高度scrollHeight - 一屏幕高度clientHeight
box.scrollTop
box.scrollLeft

//=>13个盒子模型属性，只有这两个是“可读写”的属性（既可以获取也可以设置对应的值），其余的都是“只读”属性（不能设置值，只能获取）
box.scrollTop=0;
~~~

~~~js
//=>offsetParent：获取它的父参照物（不一定是父元素）
//父参照物和它的父元素没有必然的联系，父参照物查找：同一个平面中，最外层元素是所有后代元素的父参照物，而基于position:relative/absolute/fixed可以让元素脱离文档流（一个新的平面），从而改变元素的父参照物
document.body.offsetParent === null;

//=>offsetTop：距离其父参照物的上偏移
//=>offsetLeft：距离其父参照物的左偏移（当前元素的外边框到父参照物的里边框）

/*
 * offset：获取当前元素距离BODY的左/上偏移（不论其父参照物是谁）
 *   @params
 *      curEle:current element当前要操作的元素
 *   @return
 *      [object]包含上/左偏移的信息  => {top:xxx,left:xxx} 
 * by yuanzhililan on 2019/08/14
*/
function offset(curEle) {
    let par = curEle.offsetParent,
        l = curEle.offsetLeft,
        t = curEle.offsetTop;
    //存在父参照物，而且还没有找到BODY
    while (par && par.tagName !== "BODY") {
        //在原有偏移的基础上累加：父参照物的边框、父参照物的偏移
        if (!/MSIE 8\.0/.test(navigator.userAgent)) {
            //IE8中偏移值自已就算了边框了，不需要我们在加边框的值 navigator.userAgent获取当前浏览器的版本信息
            l += par.clientLeft;
            t += par.clientTop;
        }
        l += par.offsetLeft;
        t += par.offsetTop;
        //继续获取上级参照物
        par = par.offsetParent;
    }
    return {
        top: t,
        left: l
    };
}
~~~

#### 盒子模型

~~~HTML
/*盒子模型*/
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>JS盒子模型属性</title>
	<style>
		* {
			margin: 0;
			padding: 0;
		}

		.box {
			box-sizing: border-box;
			margin: 20px auto;
			padding: 15px;
			width: 300px;
			height: 300px;
			border: 10px solid lightblue;
			background: lightcyan;
			font-size: 18px;
			line-height: 80px;
			overflow: auto;
		}
	</style>
</head>

<body>
	<div id="box" class="box">
		夫君子之行，静以修身，俭以养德，非淡泊无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非志无以成学。淫漫则不能励精，险躁则不能冶性，年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及~~
	</div>


</body>

</html>
~~~

#### client系列（实现居中处理的多种办法）

~~~HTML
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>JS盒子模型属性</title>
	<style>
		* {
			margin: 0;
			padding: 0;
		}

		html,
		body {
			height: 100%;
		}

		.box {
			box-sizing: border-box;
			padding: 15px;
			width: 300px;
			height: 300px;
			border: 10px solid lightblue;
			background: lightcyan;
			font-size: 18px;
			line-height: 30px;
		}

		/* 居中：定位  */
		/* .box {
			position: absolute;
			top: 50%;
			left: 50%;
			margin-left: -150px;
			margin-top: -150px;
		} */

		/* .box {
			position: absolute;
			top: 50%;
			left: 50%;
			/!* 基于CSS3变形属性中的位移，在不知道宽高的情况下也能实现效果 *!/
			transform: translate(-50%, -50%);
		} */

		/* .box {
			position: absolute;
			top: 0;
			left: 0;
			bottom: 0;
			right: 0;
			margin: auto;
		} */

		/* FLEX :http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html*/
		/* body {
			display: flex;
			/!* 设置元素在FLEX容器主轴和交叉轴方向上的对齐方式：CENTER居中对齐 *!/
			justify-content: center;
			align-items: center;
		} */
	</style>
</head>

<body>
	<div id="box" class="box">
		夫君子之行，静以修身，俭以养德，非淡泊无以明志，非宁静无以致远。夫学须静也，才须学也，非学无以广才，非志无以成学。淫漫则不能励精，险躁则不能冶性，年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及~~
	</div>
	<script>
		// JS实现居中：(一屏幕的宽度-盒子的宽度)/2 === LEFT
		let winW = document.documentElement.clientWidth,
			winH = document.documentElement.clientHeight,
			box = document.getElementById('box');
		box.style.position = 'absolute';
		box.style.left = (winW - 300) / 2 + 'px';
		box.style.top = (winH - 300) / 2 + 'px';
	</script>
</body>

</html>
~~~

#### scroll系列（回到顶部案例）

~~~html
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>回到顶部</title>
	<style>
		* {
			margin: 0;
			padding: 0;
		}

		html,
		body {
			height: 1000%;
			/* CSS3中的背景颜色线性渐变 */
			background: -webkit-linear-gradient(top left, lightblue, lightpink, lightyellow);
		}

		.link {
			display: none;
			position: fixed;
			right: 30px;
			bottom: 230px;
			box-sizing: border-box;
			width: 100px;
			height: 100px;
			background: lightcoral;
			font-size: 16px;
			color: #000;
			text-decoration: none;
			text-align: center;
			line-height: 100px;
		}
	</style>
</head>

<body>
	<a href="javascript:;" id="link" class="link">回到顶部</a>

	<script>
		let HTML = document.documentElement,
			LINK = document.getElementById('link');

		// 1.当浏览器滚动条滚动的时候，我们进行验证：卷去的高度超过两屏，我们让#LINK显示
		function check() {
			//winH:一屏幕高度  scrollT:卷去的高度
			let winH = HTML.clientHeight,
				scrollT = HTML.scrollTop;
			LINK.style.display = scrollT >= winH * 2 ? 'block' : 'none';
		}
		window.onscroll = check;

		// 2.点击回到顶部
		LINK.onclick = function () {
			/* 让按钮隐藏 */
			LINK.style.display = 'none';
			//先禁止滚动事件触发（因为在回到顶部的运动过程中，如果事件一直在，会计算按钮显示隐藏的样式，无法让按钮隐藏）
			window.onscroll = null;

			/* 实现动画 */
			let step = 1000;
			let timer = setInterval(() => {
				//每一次获取最新的SCROLL-TOP值，在现有的基础上减去步长，让其走一步
				let curT = HTML.scrollTop;
				if (curT === 0) {
					//边界判断：已经回到顶部后，我们清除定时器
					clearInterval(timer);
					//恢复滚动条滚动的监听事件
					window.onscroll = check;
					return;
				}
				curT -= step;
				HTML.scrollTop = curT;
			}, 17);
		};


		//SET-INTERVAL：设置一个定时器（TIMER代表这个定时器），每间隔INTERVAL这么久，就会把FUNCTUION执行一次...一直到手动清除定时器为止
		// let timer = setInterval([FUNCTUION], [INTERVAL]);
		// clearInterval(timer);
	</script>
</body>

</html>
~~~

#### offset系列（获取元素的偏移值）

~~~js
/*
 * offset：获取当前元素距离BODY的左/上偏移（不论其父参照物是谁）
 *   @params
 *      curEle:current element当前要操作的元素
 *   @return
 *      [object]包含上/左偏移的信息  => {top:xxx,left:xxx} 
 * by yuanzhililan on 2019/08/14
*/
function offset(curEle) {
    let par = curEle.offsetParent,
        l = curEle.offsetLeft,
        t = curEle.offsetTop;
    //存在父参照物，而且还没有找到BODY
    while (par && par.tagName !== "BODY") {
        //在原有偏移的基础上累加：父参照物的边框、父参照物的偏移
        if (!/MSIE 8\.0/.test(navigator.userAgent)) {
            //IE8中偏移值自已就算了边框了，不需要我们在加边框的值 navigator.userAgent获取当前浏览器的版本信息
            l += par.clientLeft;
            t += par.clientTop;
        }
        l += par.offsetLeft;
        t += par.offsetTop;
        //继续获取上级参照物
        par = par.offsetParent;
    }
    return {
        top: t,
        left: l
    };
}
~~~

![获取元素的偏移值](C:\Users\左海之浅\Desktop\课程笔记\图片文件\获取元素的偏移值.png)

### 获取元素的样式：getComputedStyle

> 获取当前元素所有经过浏览器计算过的样式
>
> - 只要元素在页面中呈现出来，那么所有的样式都是经过浏览器计算的
> - 哪怕你没有设置和见过的样式也都计算过
> - 不管你写或者不写，也不论写在哪，样式都在这，可以直接获取
>
> 在IE6~8浏览器中不兼容，需要基于currentStyle来获取

~~~js
//=>第一个参数是操作的元素  第二个参数是元素的伪类:after/:before
//=>获取的结果是CSSStyleDeclaration这个类的实例（对象），包含了当前元素所有的样式信息
let styleObj = window.getComputedStyle([element],null);
styleObj["backgroundColor"]
styleObj.display

//=>IE6~8
styleObj = [element].currentStyle;
~~~

### 单张图片延迟加载

~~~HTML
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>图片延迟加载</title>
	<style>
		* {
			margin: 0;
			padding: 0;
		}

		img {
			border: none;
		}

		img[src=""] {
			display: none;
		}

		.imgBox {
			box-sizing: border-box;
			margin: 800px auto;
			width: 300px;
			height: 245px;
			background: #CCC;
		}

		.imgBox img {
			display: none;
			width: 100%;
			height: 100%;
		}
	</style>
</head>

<body>
	<!-- 
		图片延迟加载 “图片懒加载”
		1.结构中，我们用一个盒子包裹着图片（在图片不展示的时候，可以占据着这个位置，并且设置默认的背景图或者背景颜色）
		2.最开始，IMG的SRC中不设置任何的图片地址，把图片的真实地址设置给自定义属性DATA-SRC/TRUE-IMG（最开始不展示图片:可以让图片隐藏）
		3.当浏览器窗口完全展示到图片位置的时候，我们再去加载真实图片，并且让其显示出来（第一屏幕中的图片一般都会延迟加载，来等待其它资源先加载完）
	 -->
	<div class="imgBox">
		<img src="" alt="" trueImg="images/IE3.jpg">
	</div>

	<!-- IMPORT JS -->
	<script src="4.延迟加载.js"></script>
</body>

</html>
~~~

~~~js
/*
 * offset：获取当前元素距离BODY的左/上偏移（不论其父参照物是谁）
 *   @params
 *      curEle:current element当前要操作的元素
 *   @return
 *      [object]包含上/左偏移的信息  => {top:xxx,left:xxx} 
 * by yuanzhililan on 2019/08/14
 */
function offset(curEle) {
	let par = curEle.offsetParent,
		l = curEle.offsetLeft,
		t = curEle.offsetTop;
	while (par && par.tagName !== "BODY") {
		if (!/MSIE 8\.0/.test(navigator.userAgent)) {
			l += par.clientLeft;
			t += par.clientTop;
		}
		l += par.offsetLeft;
		t += par.offsetTop;
		par = par.offsetParent;
	}
	return {
		top: t,
		left: l
	};
}


/*
 * 图片完全显示出来的条件 
 *   A:盒子底边距离BODY（页面最顶端）的距离：盒子的高度+盒子距BODY的上偏移
 *   B:浏览器底边距离BODY的距离：一屏幕的高度 + 卷去的高度
 *   A<=B：盒子就完全出现在用户的视野中
 * 让图片显示
 *   获取图片TRUE-IMG属性的值，赋值给SRC属性，当图片能正常加载出来后，让图片显示即可
 */
let imgBox = document.querySelector('.imgBox'),
	_img = imgBox.querySelector('img');

//=>显示图片 
//curImg:要显示的图片
function lazyImg(curImg) {
	//给SRC赋值真实的图片地址
	let trueImg = curImg.getAttribute("trueImg");
	curImg.src = trueImg;
	//校验图片是否能够正常加载出来：IMG.ONLOAD事件用来监听图片是否能加载
	curImg.onload = function () {
		curImg.style.display = 'block';
	};
	//=>设置自定义属性:isLoad存储当前图片已经加载过了
	curImg.isLoad = true;
}

//=>监听页面滚动事件（不论基于什么方式，只要页面滚动了，则触发事件）
window.onscroll = function () {
	//=>已经加载过就不要在重复加载了
	if (_img.isLoad) return;

	let HTML = document.documentElement,
		B = HTML.clientHeight + HTML.scrollTop,
		A = imgBox.offsetHeight + offset(imgBox).top; //=>当前案例中，获取距离BODY的上偏移完全可以imgBox.offsetTop，因为父参照物就是BODY
	if (A <= B) {
		//=>符合图片显示的条件了
		lazyImg(_img);
	}
};
~~~

![延迟加载](C:\Users\左海之浅\Desktop\课程笔记\图片文件\延迟加载.png)

## 二十四.jQuery

> 一款伟大的，用原生JS封装的，“操作DOM”的类库：它里面封装了大量的方法（在原先的版本中 v1.xxx，这些方法兼容所有的浏览器），基于这些方法我们可以快速的进行DOM操作和项目开发

### 如何学习jQuery

- 看API文档

  http://jquery.cuishifeng.cn/

- 看书籍

  《锋利的jQuery第二版》

- 大量做案例

  在学习阶段，案例可以用原生JS做一遍，再用JQ做一遍

- 学习JQ源码

  - 更好的掌握JQ的应用，写出高性能可扩展的项目代码
  - 让自己的JS能力，尤其是组件插件等封装的能力直接上一个新台阶

### JQ的三大版本

- v1.xxx 第一代版本

  - jQuery-1.11.3.min.js 这个是我最常用的

  第一代版本的特点：大而全，方法是兼容所有浏览器的（包括IE6），主要应用于需要考虑兼容的PC端项目

- v2.xxx 第二代版本

  主要是为移动端的开发准备的，不在兼容低版本浏览器（例如：IE8及以下），配合出现的还有jQuery mobile等UI库；但是，第二代版本在移动端方面的处理不如Zepto.js

- v3.xxx 第三代版本

  也不再兼容IE低版本浏览器了，它从性能等方面都要比之前的强，但是生不逢时，此时正好是angular /  vue / react 这种框架崛起的时代，大家已经不再基于操作DOM的思想开发了，JQ也就慢慢退出舞台了

### JQ中常用的方法

~~~js
//=>1.获取DOM元素
//操作方法：JQ选择器（根据选择器类型快速获取需要的元素）
$([selector],[context])
	$('#box')
	$('.imgBox')
	$('.box a')
    $('a',box)
    ...
/*JQ支持的选择器：传统CSS3中的大部分都支持、还支持一些自己独有的
 * :eq(n) 获取集合中索引为n的
 * :gt(n) 大于这个索引的
 * :lt(n) 小于这个索引的
 */    

------------------------------    
    
//节点之间关系的属性：用JQ选择器获取的元素，我们设置变量名的时候一般都以$开始
//=>还可以再设置对应的选择器进行二次筛选
let $box = $('.box');
$box.children('a'); //=>获取对应的子元素
$box.find('a'); //=>获取对应的后代元素
$('a').filter('.active'); //=>同级筛选（在所有的A中筛选出具备CLASS='ACTIVE'样式类的A）
$box.prev();
$box.prev('p'); //=>获取它上一个标签名为P的哥哥
$box.prevAll();
$box.next();
$box.nextAll('.link');
$box.siblings(); //=>获取所有的兄弟
$box.index(); //=>获取索引
$box.parent(); //=>获取父元素
$box.parents(); //=>获取所有的祖先元素，一直到document

------------------------------  

//=>2.DOM增删改
let str = `<div id="box" class='box'>
	...
</div>`;
$('body').append(str); //=>追加到容器BODY的末尾
$('body').html(str); //=>等价于innerHTML  $('body').html()不传参是获取BODY中的HTML内容，除了这个方法还有text方法，等价于innerText

$A.insertBefore($B); //=>把$A放到$B的前面（注意点：$A,$B都是页面中已经存在的元素）
$A.insertAfter($B); //=>把$A放到$B的后面
$(`<div id="box" class='box'>
	哈哈
</div>`).insertBefore($A); //=>需要把新增加元素放到$A前面，需要把字符串用$()包起来，相当于创建了一个元素

$A.appendTo($B); //=>$B.append($A) 在$B容器的末尾追加$A
$A.prependTo($B); //=>$B.prepend($A) 在$B容器的开头追加$A

$A.clone();  //=>实现元素的克隆
$A.remove(); //=>实现元素的删除

//=>操作表单元素的内容
$inp.val() //获取表单元素内容
$inp.val('AAA') //设置表单元素内容
//html和text方法是操作非表单元素内容的

------------------------------  

//=>3.操作自定义属性
$box.attr('data-type') //=>获取自定义属性值
$box.attr('data-type','B') //=>设置自定义属性值
$box.attr({
    'type':1,
    'name':'AA'
}); //=>批量设置
$box.removeAttr('data-type');//=>移除自定义属性
//表单元素操作内置或者自定义属性一般使用prop和removeProp
$radio.prop('checked')
$radio.prop('checked',true)
...

//=>4.操作CSS样式（盒子模型属性）
//设置样式
$box.css('width',200); //=>css方法是设置或者批量设置样式（原理是设置STYLE行内样式）$box.css({ width:200,height:200 })，写的值不加单位，方法会帮我们自动设置上px单位
$box.addClass('active');//=>设置样式类（原理是对className的操作），removeClass是移除，hasClass验证是否存在某个样式类，toggleClass之前有就是移除，没有就是新增

//获取样式
$box.css('width'); //=>不设置值的时候就是获取（原理是getComputedStyle，所有经过计算的样式都可以获取）
$box.offset(); //=>当前元素距离BODY的左偏移和上偏移
$box.position(); //=>当前元素距离父参照物的左偏移和上偏移
$box.innerWidth/.innerHeight/.outerWidth/.outerHeight() //=>等价于clientWidth/Height 和 offsetWidth/Height
$(document).scrollTop([val]); //=>可以获取或者设置scrollTop的信息，对应的方法 .scrollLeft
~~~

**除了操作DOM，JQ中还提供了其它有助于项目开发的方法**

~~~js
//=>事件处理
//$元素.on([event type],[function])
//$元素.off([event type],[function])
//$元素.bind()  $元素.unbind()  $元素.delegate() ...
//$元素.click() .mouseover .mouseout ...等常用事件的快捷绑定
$box.on('click',function(){});
$box.click(function(){});

//=>动画处理
//.animate([目标样式],[总时间],[运动方式],[运动完做的事情])
//.stop / .finish
$box.stop().animate({
    top:100,
    left:200
},1000,'linear',function(){});

//=>AJAX请求处理
let _DATA=null;
$.ajax({
    url:'json/product.json',
    method:'GET',
    async:false,
    dataType:'json',
    success:result=>{
        //result:当请求成功执行success函数，result就是从服务器获取的结果
        _DATA=result;
    }
});

//=>常用的工具方法
$.each([数组、类数组、对象],function(index,item){
    //=>遍历数组中的每一项 index:索引 item:当前循环这一项（对象：index是属性名 item属性值）
});
$('A').each(function(index,item){});

//$.toArray()转换为数组  $.merge()数组合并  $.makeArray()把类数组转换为数组  $.uniqueSort()去重加排序  $.type数据类型检测 ...
~~~

### 案例：JQ实现选项卡

~~~html
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>选项卡</title>
	<!-- IMPORT CSS -->
	<style>
		* {
			margin: 0;
			padding: 0;
		}

		ul {
			list-style: none;
		}

		.tabBox {
			box-sizing: border-box;
			margin: 20px auto;
			width: 500px;
		}

		.navBox {
			display: flex;
			position: relative;
			top: 1px;
		}

		.navBox li {
			box-sizing: border-box;
			margin-right: 10px;
			padding: 0 10px;
			line-height: 35px;
			border: 1px solid #999;
		}

		.navBox li.active {
			border-bottom-color: #FFF;
		}

		.tabBox>div {
			display: none;
			box-sizing: border-box;
			padding: 10px;
			height: 150px;
			border: 1px solid #999;
		}

		.tabBox>div.active {
			display: block;
		}
	</style>

	<script>
		//=>在结构加载之前获取元素肯定获取不到，所以我们一般把JS放到BODY末尾（就是为了等待结构加载完再去获取元素）
		// let tabBox = document.getElementById('tabBox');
		// console.log(tabBox); //=>null

		//1.如果不需要获取页面中的元素，放到哪都可以
		//2.就是想放到开头，还想获取元素，可以基于window.onload或者JQ中的$(document).ready()来处理
	</script>
</head>

<body>
	<div class="tabBox">
		<ul class="navBox">
			<li class="active">编程</li>
			<li>读书</li>
			<li>运动</li>
		</ul>
		<div class="active">编程使我快乐</div>
		<div>读书使我幸福</div>
		<div>运动使我健康</div>
	</div>

	<!-- IMPORT JS -->
	<script src="node_modules/jquery/dist/jquery.min.js"></script>
	<script>
		$('.tabBox>.navBox>li').click(function () {
			let n = $(this).index();
			$(this).addClass('active')
				.siblings().removeClass('active')
				.parent()
				.nextAll('div').eq(n).addClass('active')
				.siblings().removeClass('active');
		});
	</script>

	<script>
		/* 
		 * $([function])：等待页面中所有的DOM结构加载完成才会执行这个方法 
		 * => $(document).ready([function])
		 *  
		 * window.onload=function(){} ：等待页面中所有的资源（DOM结构、内容、其它的富媒体资源等）都加载完成才会执行函数
		 */
		/* $(function () {
			//=>选项卡正常思路：给所有的LI绑定点击事件 ，当点击某一个LI的时候，让其有选中样式，而其余的LI都移除选中样式，同时对应索引的DIV有选中样式，其余的DIV移除选中样式即可，这样就可以实现选项卡切换效果
			let $tabBox = $('#tabBox'),
				$navList = $tabBox.find('#navBox>li'),
				$divList = $tabBox.children('div');
			//=>JQ特性：内置循环处理机制（基于一个JQ集合去操作某个方法，我们无需循环每一项单独操作，JQ内部帮我们循环处理了，例如：$navList.css('color','#000')集合中有100项，JQ会把100项都设置了这个样式，无需自己循环处理 ）
			$navList.on('click', function () {
				//=>THIS:当前点击操作的元素 =>$(this)此能调取JQ方法
				//=>JQ特性：链式写法
				let n = $(this).index();
				$(this).addClass('active').siblings().removeClass('active');
				//=>根据点击LI的索引，在DIV集合中找到对应的那一项，然后这一项选中，它的兄弟项都移除选中即可
				$divList.eq(n).addClass('active').siblings().removeClass('active');
			});

			//=>基于JQ中的EACH遍历集合中的每一项，绑定点击事件
			// $navList.each(function (index, $item) {
			// 	//参数顺序和内置的FOR-EACH是反着的
			// 	//index:当前循环这一项的索引
			// 	//$item:当前循环的这一项 
			// 	//this===$item：当前方法中的THIS也是循环的这一项
			// 	$item.on('click', function () {
			// 		//...
			// 	});
			// });
			// $navList.each((index, $item) => {
			// 	//=>THIS不再是循环的这一项（箭头函数中没有THIS）
			// });
		}); */
	</script>
</body>

</html>
~~~

### JQ源码

~~~js
(function (global, factory) {
	"use strict";
	if (typeof module === "object" && typeof module.exports === "object") {
		//......
		//=>支持CommonJS模块规范的执行这里（例如:NODE.JS）
	} else {
		//=>可以初步理解为是浏览器或者(WEB-WIEW)环境
		//global===window
		//factory===function(window, noGlobal){  }
		factory(global);
	}
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
	//=>参数信息
	//window===window
	//noGlobal===undefined
	"use strict";

	var version = "3.4.1",
		jQuery = function (selector, context) {
			return new jQuery.fn.init(selector, context);
		};

	//=>jQuery是一个类，jQuery.fn是给原型设置一个别名
	jQuery.fn = jQuery.prototype = {
		//=>公共的属性和方法
		jquery: version,
		constructor: jQuery,
		length: 0,
		//转换为数组的方法
		toArray: function () {
			//=>this:一般是当前类jQuery的实例
			return slice.call(this);
		},
		//把JQ对象转换为原生JS对象
		get: function (num) {
			if (num == null) {
				return slice.call(this);
			}
			return num < 0 ? this[num + this.length] : this[num];
		},
		eq: function (i) {
			var len = this.length,
				j = +i + (i < 0 ? len : 0);
			return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
		},
		//....
	};

	//=>jQuery是一个普通对象
	jQuery.ajax = function (url, options) {
		//...
	};

	var init = jQuery.fn.init = function (selector, context, root) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if (!selector) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery; //=>rootjQuery = jQuery(document);

		// Handle HTML strings
		if (typeof selector === "string") {
			if (selector[0] === "<" &&
				selector[selector.length - 1] === ">" &&
				selector.length >= 3) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [null, selector, null];

			} else {
				match = rquickExpr.exec(selector);
			}

			// Match html or make sure no context is specified for #id
			if (match && (match[1] || !context)) {

				// HANDLE: $(html) -> $(array)
				if (match[1]) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge(this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					));

					// HANDLE: $(html, props)
					if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
						for (match in context) {

							// Properties of context are called as methods if possible
							if (isFunction(this[match])) {
								this[match](context[match]);

								// ...and otherwise set as attributes
							} else {
								this.attr(match, context[match]);
							}
						}
					}

					return this;

					// HANDLE: $(#id)
				} else {
					elem = document.getElementById(match[2]);

					if (elem) {

						// Inject the element directly into the jQuery object
						this[0] = elem;
						this.length = 1;
					}
					return this;
				}

				// HANDLE: $(expr, $(...))
			} else if (!context || context.jquery) {
				return (context || root).find(selector);

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor(context).find(selector);
			}

			// HANDLE: $(DOMElement)
		} else if (selector.nodeType) {
			this[0] = selector;
			this.length = 1;
			return this;

			// HANDLE: $(function)
			// Shortcut for document ready
		} else if (isFunction(selector)) {
			return root.ready !== undefined ?
				root.ready(selector) :

				// Execute immediately if ready is not present
				selector(jQuery);
		}

		return jQuery.makeArray(selector, this);
	};

	init.prototype = jQuery.fn;

	var
		_jQuery = window.jQuery,
		_$ = window.$;

	jQuery.noConflict = function (deep) {
		if (window.$ === jQuery) {
			window.$ = _$;
		}

		if (deep && window.jQuery === jQuery) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	};

	jQuery.extend = jQuery.fn.extend = function () {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if (typeof target === "boolean") {
			deep = target;

			// Skip the boolean and the target
			target = arguments[i] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if (typeof target !== "object" && !isFunction(target)) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if (i === length) {
			target = this;
			i--;
		}

		for (; i < length; i++) {

			// Only deal with non-null/undefined values
			if ((options = arguments[i]) != null) {

				// Extend the base object
				for (name in options) {
					copy = options[name];

					// Prevent Object.prototype pollution
					// Prevent never-ending loop
					if (name === "__proto__" || target === copy) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (jQuery.isPlainObject(copy) ||
							(copyIsArray = Array.isArray(copy)))) {
						src = target[name];

						// Ensure proper type for the source value
						if (copyIsArray && !Array.isArray(src)) {
							clone = [];
						} else if (!copyIsArray && !jQuery.isPlainObject(src)) {
							clone = {};
						} else {
							clone = src;
						}
						copyIsArray = false;

						// Never move original objects, clone them
						target[name] = jQuery.extend(deep, clone, copy);

						// Don't bring in undefined values
					} else if (copy !== undefined) {
						target[name] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	if (!noGlobal) {
		//把jQuery赋值给window下的jQuery和$
		window.jQuery = window.$ = jQuery;
	}
});
// extend：向JQ中继续扩展方法
// $.extend({}); //=>扩展到JQ对象上：一般是为了完善类库，提供更多的工具方法
// $.extend(true, {});
// $.fn.extend(); //=>扩展到JQ原型上：一般是为了写JQ插件，让JQ的实例来调用

// $.extend(true, {
// 	queryURLParams: function (url) {
// 		//...
// 	}
// });
// $.queryURLParams("http://....");


// 转移$的使用权
// let j = jQuery.noConflict(true); //=>j===jQuery
// jQuery();
// j();

//外面可以调用了
// $()
// jQuery()

/*
 * 基于JQ选择器创建出来的是JQ类的一个实例，就可以调取jQuery.prototype上的方法
 *   1.创建出来的JQ实例是一个类数组（JQ对象） 基于makeArray创建出来的
 *   2.SELECTOR支持三种数据格式
 *     [STRING]
 *        选择器 $('.box')
 *        创建元素 $('<div>...</div>')
 *     [元素对象：JS原生对象]
 *        把原生JS对象转换为JQ对象（只有这样才能调取JQ中的方法）
 *        把JQ对象转换为原生对象，直接基于索引获取即可，例如：$A[0]，真实项目中建议大家使用JQ自带的get方法实现，因为它更加完善，可以支持负数索引 $A.get(0)
 *        eq方法也是根据索引获取集合中的某一项（也支持负数索引），只不过返回的结果不是原生JS对象，依然是JQ的一个实例
 *     [函数]
 *        $(function(){}) 等待页面中的DOM结构加载完成再执行函数，等价于 $(document).ready(function(){})
 */
// $('.box')===$('.box')：false
// let $box=$('.box');
// $box.css();
// $box.attr();
// $box.animate();


/* 
 * jQuery给我们提供的方法放到了两个位置上 
 *   1.原型上 jQuery.prototype={get:...}
 *     $().get()
 *     只有jQuery的实例才可以调用
 * 
 *   2.对象上 jQuery.ajax=...
 *     $.ajax()
 *     直接调取使用
 */

/* JQ中只有一个EACH：用来遍历数组、对象、类数组中的每一项的，$a.each()最后也会转换为$.each($a)这种模式 */
/*
 * each: function (callback) {
	    //this:$navList
		return jQuery.each(this, callback);
   }
   each: function (obj, callback) {
		var length, i = 0;
		if (isArrayLike(obj)) {
			length = obj.length;
			for (; i < length; i++) {
				if (callback.call(obj[i], i, obj[i]) === false) {
					//=>每循环一次，执行一次函数，把函数中的this设置为循环项
					//传递索引和循环项
					break;
				}
			}
		} else {
			for (i in obj) {
				if (callback.call(obj[i], i, obj[i]) === false) {
					break;
				}
			}
		}
		return obj;
	},
 */
// $navList.each(function (index, item) {

// });
// $.each($navList, function (index, item) {
// 	//=>this:循环的这一项
// 	//return false; 可以控制循环结束
// });

// 检测当前对象是数组还是类数组
/* function isArrayLike(obj) {
	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType(obj);
	if (isFunction(obj) || isWindow(obj)) {
		return false;
	}
	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && (length - 1) in obj;
} */
~~~

![JQ对象和原生JS对象的属性和方法不能互相调用](C:\Users\左海之浅\Desktop\课程笔记\图片文件\JQ对象和原生JS对象的属性和方法不能互相调用.png)

![dir(C:\Users\左海之浅\Desktop\课程笔记\图片文件\dir(jQuery.prototype)JQ支持的选择器.jpg)JQ支持的选择器](C:\Users\左海之浅\Pictures\Saved Pictures\dir(jQuery.prototype)JQ支持的选择器.jpg)

### 案例：shop商城排序

**HTML&CSS**

~~~html
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>珠峰培训-商城排序DEMO</title>
	<!-- IMPORT CSS -->
	<link rel="stylesheet" href="../node_modules/bootstrap/dist/css/bootstrap.min.css">
	<style>
		.container {
			padding: 0;
		}

		.card-deck {
			margin-top: 20px;
			/* 控制折行 */
			flex-wrap: wrap;
			margin-left: 0;
			margin-right: 0;
		}

		.card-deck .card {
			margin: 0 5px 10px 5px;
			flex: 0 0 218px;
		}

		.card-deck .card .card-text {
			margin-bottom: 10px;
		}
	</style>
</head>

<body>
	<div class="container">
		<!-- NAV导航 -->
		<nav class="navbar navbar-expand-lg navbar-light bg-light">
			<a class="navbar-brand" href="javascript:;">商城排序</a>
			<div class="collapse navbar-collapse">
				<ul class="navbar-nav">
					<!-- 设置自定义属性pai，存储排序的标识 -->
					<li class="nav-item" pai="time">
						<a class="nav-link" href="javascript:;">上架时间</a>
					</li>
					<li class="nav-item" pai="price">
						<a class="nav-link" href="javascript:;">价格</a>
					</li>
					<li class="nav-item" pai="hot">
						<a class="nav-link" href="javascript:;">热度</a>
					</li>
				</ul>
			</div>
		</nav>
		<!-- CARD-LIST商品列表 -->
		<div class="card-deck">
			<!-- <div class="card">
				<img class="card-img-top" src="img/1.jpg" alt="">
				<div class="card-body">
					<h6 class="card-title">HUAWEI Mate 10 4GB+64GB 全网通版（亮黑色）</h6>
					<p class="card-text">价格：￥5000</p>
					<p class="card-text">好评：100000</p>
					<p class="card-text"><small class="text-muted">上架时间：2019-08-07</small></p>
				</div>
			</div> -->
		</div>
	</div>

	<!-- IMPORT JS -->
	<script src="../node_modules/jquery/dist/jquery.min.js"></script>
	<script src="js/index.js"></script>
</body>

</html>
~~~

**JS**

~~~JS
/*
 * 基于单例设计模式来管理商城排序的代码
 */
let shopModule = (function ($) {
	//=>想要操作谁就先获取谁（项目中尽可能把创建变量提前并放在一起）
	let $navList = $('.navbar-nav li'),
		$cardBox = $('.card-deck'),
		$cardList = null,
		_DATA = null;

	//=>queryData:从服务器获取数据
	function queryData() {
		//基于JQ中的AJAX方法获取数据
		$.ajax({
			url: 'json/product.json',
			method: 'GET',
			async: false,
			success: result => {
				//从服务器获取数据成功会执行SUCCESS，RESULT存储的就是获取到的数据（并且数据默认就已经转换为JSON格式的对象）
				_DATA = result;
			}
		});
	}

	//=>bindHTML:把数据绑定在页面中
	function bindHTML() {
		if (!_DATA) return;

		let HTML = ``;
		$.each(_DATA, (index, item) => {
			let {
				title,
				img,
				price,
				hot,
				time
			} = item;
			HTML += `<div class="card" time="${time}" price="${price}" hot="${hot}">
				<img class="card-img-top" src="${img}" alt="">
				<div class="card-body">
					<h6 class="card-title">${title}</h6>
					<p class="card-text">价格：￥${price}</p>
					<p class="card-text">好评：${hot}</p>
					<p class="card-text">
						<small class="text-muted">上架时间：${time}</small>
					</p>
				</div>
			</div>`;
		});
		$cardBox.html(HTML);
		//=>获取所有的CARD
		$cardList = $cardBox.children('.card');
	}

	//=>sortHandle:实现商城排序
	function sortHandle() {
		$navList.attr('typeA', -1);
		$navList.on('click', function () {
			//=>THIS:当前点击的LI（原生JS对象） =>$(THIS)变为JQ对象
			let $this = $(this),
				pai = $this.attr('pai'); //=>'time'/'price'/'hot'
			$this.attr('typeA', $this.attr('typeA') * -1).siblings().attr('typeA', -1);
			$cardList.sort((A, B) => {
				let $A = $(A),
					$B = $(B);
				$A = $A.attr(pai);
				$B = $B.attr(pai);
				pai === "time" ? ($A = $A.replace(/-/g, ""), $B = $B.replace(/-/g, "")) : null;
				return ($A - $B) * $this.attr('typeA');
			});
			$cardList.each((index, item) => $cardBox.append(item));
		});
	}

	return {
		//=>当前模块的入口：想让商城排序开始执行，我们只需要执行INIT，在INIT中会按照顺序，依次完成具体的业务逻辑
		init() {
			queryData();
			bindHTML();
			sortHandle();
		}
	}
})(jQuery);

shopModule.init();
~~~

### 案例：computed计算购物车

~~~html
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>珠峰培训</title>
	<!-- IMPORT CSS -->
	<link rel="stylesheet" type="text/css" href="price.css" />
</head>

<body>
	<div class="wrap">
		<div class="box">
			<ul class="list">
				<!-- <li>
					<i></i>
					<em>0</em>
					<i></i>
					<span>
						单价：<strong>12.5元</strong>
						小计：<strong>0元</strong>
					</span>
				</li> -->
			</ul>
			<div class="info">
				<!-- <span>商品公合计：<em>0</em>件</span>
				<span>共花费了：<em>0</em>元</span>
				<span>其中最贵的商品单价是：<em>0</em>元</span> -->
			</div>
		</div>
	</div>

	<!-- IMPORT JS -->
	<script src="../node_modules/jquery/dist/jquery.min.js"></script>
	<script src="index.js"></script>
</body>

</html>
~~~

~~~js
/* let cartModule = (function ($) {
	let $btns = $('.list i'),
		$counts = $('.list em'),
		$strongs = $('.list strong'),
		$ems = $('.info em');

	//=>实现加号减号的点击事件
	function handleClick() {
		$btns.click(function () {
			let $this = $(this),
				n = $this.index(); //=>JQ中的INDEX获取的是元素在兄弟结构中的索引
			//=>根据点击按钮，获取当前行中：存储数字、单价、总价这几个元素
			let $par = $this.parent(),
				$count = $par.children('em'),
				$strongs = $par.find('strong'),
				$price = $strongs.eq(0), //=>eq获取的依然是JQ对象,get获取的是JS对象
				$total = $strongs.eq(1);
			//=>0减号 2加号 根据点击的加减号，计算出最新购买的数量
			let x = parseFloat($count.html());
			if (n === 0) {
				x--;
				x < 0 ? x = 0 : null;
			} else {
				x++;
				x > 10 ? x = 10 : null;
			}
			$count.html(x);
			//=>获取单价计算总价
			$total.html(parseFloat($price.html()) * x + '元');
			//=>计算总信息
			computed();
		});
	}

	//=>计算总信息
	function computed() {
		let allCount = 0,
			allMoney = 0,
			allPrice = [];
		//=>计算总购买数
		$counts.each((index, item) => {
			allCount += parseFloat($(item).html());
		});
		$ems.eq(0).html(allCount);

		//=>计算总价格和最高单价
		$strongs.each((index, item) => {
			let itemVal = parseFloat($(item).html());
			if (index % 2 === 1) {
				allMoney += itemVal;
			} else {
				//=>只有购买了才进入比较的序列
				if (parseFloat($(item).next('strong').html()) !== 0) {
					allPrice.push(itemVal);
				}
			}
		});
		$ems.eq(1).html(allMoney);
		$ems.eq(2).html(Math.max(...allPrice));
	}

	return {
		init() { //=>init:function(){}
			handleClick();
		}
	}
})(jQuery);

cartModule.init(); */

//==========================================
let cartModule = (function ($) {
	let $list = $('.list'),
		$info = $('.info'),
		$btns = null;

	//=>准备数据模型（页面就是按照数据模型渲染出来的）
	let _DATA = [{
		id: 1,
		count: 0,
		price: 12.5,
		total: 0
	}, {
		id: 2,
		count: 0,
		price: 10.5,
		total: 0
	}, {
		id: 3,
		count: 0,
		price: 8.5,
		total: 0
	}, {
		id: 4,
		count: 0,
		price: 8,
		total: 0
	}, {
		id: 5,
		count: 0,
		price: 14.5,
		total: 0
	}];

	//=>render:按照数据模型渲染视图
	function render() {
		//渲染操作区域视图
		let str = ``;
		$.each(_DATA, (index, item) => {
			let {
				count,
				price,
				total,
				id
			} = item;
			str += `<li>
				<i group="${id}"></i>
				<em>${count}</em>
				<i group="${id}"></i>
				<span>
					单价：<strong>${price}元</strong>
					小计：<strong>${total}元</strong>
				</span>
			</li>`;
		});
		$list.html(str);

		//渲染总计信息区视图
		let counts = 0,
			totals = 0,
			maxprice = 0;
		_DATA.forEach(item => {
			counts += item.count;
			totals += item.total;
			//=>购买才进入最高价格的计算
			if (item.count > 0) {
				maxprice < item.price ? maxprice = item.price : null;
			}
		});
		$info.html(`<span>商品公合计：<em>${counts}</em>件</span>
		<span>共花费了：<em>${totals}</em>元</span>
		<span>其中最贵的商品单价是：<em>${maxprice}</em>元</span>`);

		//执行事件绑定
		handle();
	}

	//=>handle:点击按钮操作（不操作DOM，只改变_DATA的数据）
	function handle() {
		$btns = $list.find('i');
		$btns.click(function () {
			let $this = $(this),
				n = $this.index(),
				group = parseFloat($this.attr('group'));
			//修改数据
			_DATA = _DATA.map(item => {
				if (item.id === group) {
					if (n === 0) {
						item.count--;
						item.count < 0 ? item.count = 0 : null;
					} else {
						item.count++;
						item.count > 10 ? item.count = 10 : null;
					}
					item.total = item.price * item.count;
				}
				return item;
			});
			//重新渲染
			render();
		});
	}

	return {
		init() {
			render();
		}
	}
})(jQuery);

cartModule.init();
~~~

![数据驱动](C:\Users\左海之浅\Desktop\课程笔记\图片文件\数据驱动-1566266346766.png)

### 案例：product商品筛选

~~~html
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>珠峰培训</title>
	<style type="text/css">
		body {
			font-size: 14px;
			font-family: "Lantinghei SC Extralight", Arial;
		}

		ul {
			padding: 0;
			margin: 0;
			list-style: none;
		}

		a {
			text-decoration: none;
		}

		img {
			vertical-align: top;
		}

		#wrap {
			width: 760px;
			height: 260px;
			margin: 20px auto;
			padding: 145px 120px 95px;
			background: url(img/bg.jpg) no-repeat 0 0;
		}

		#section {
			width: 760px;
			height: 260px;
			-moz-box-shadow: 0px 0px 4px rgba(0, 0, 0, .2);
			box-shadow: 0px 0px 4px rgba(0, 0, 0, .2);
		}

		#choose {
			width: 760px;
			height: 50px;
			margin: 0 auto;
			background: url(img/nav_bg.png) no-repeat 0 0;
			line-height: 50px;
			text-indent: 21px;
		}

		#type {
			width: 100%;
			height: 210px;
			background: url(img/type_bg.png) no-repeat 0 0;
			padding: 17px 0 16px 28px;
		}

		#type li {
			height: 44px;
			color: #8a8a8a;
			line-height: 44px;
		}

		#type a {
			margin: 0 12px 0 11px;
			color: #000;
		}

		#choose mark {
			position: relative;
			display: inline-block;
			height: 24px;
			line-height: 24px;
			border: 1px solid #28a5c4;
			color: #28a5c4;
			margin: 12px 5px 0;
			background: none;
			padding: 0 30px 0 6px;
			text-indent: 0;
		}

		#choose mark a {
			position: absolute;
			top: 3px;
			right: 2px;
			display: inline-block;
			width: 18px;
			height: 18px;
			background: #28a5c4;
			color: #fff;
			line-height: 18px;
			font-size: 16px;
			text-align: center;
		}
	</style>
</head>

<body>
	<div id="wrap">
		<section id="section">
			<nav id="choose">
				<!-- <mark>苹果<a href="javascript:;" _type='1'>X</a></mark> -->
			</nav>
			<ul id="type">
				<!-- <li _type='1'>
					品牌：
					<a href="javascript:;">苹果</a>
				</li> -->
			</ul>
		</section>
	</div>

	<!-- IMPORT JS -->
	<script src="../node_modules/jquery/dist/jquery.min.js"></script>
	<script src="index.js"></script>
</body>

</html>
~~~

~~~js
let filterModule = (function () {
	//=>准备两组数据
	let _SELECT = [{
		type: 1,
		name: '苹果'
	}];
	let _DATA = [{
		type: 1,
		text: '品牌',
		content: ["苹果", "小米", "锤子", "魅族", "华为", "三星", "OPPO", "vivo", "乐视", "360", "中兴", "索尼"]
	}, {
		type: 2,
		text: '尺寸',
		content: ["3.0英寸以下", "3.0-3.9英寸", "4.0-4.5英寸", "4.6-4.9英寸", "5.0-5.5英寸", "6.0英寸以上"]
	}, {
		type: 3,
		text: '系统',
		content: ["安卓", "苹果", "微软", "无", "其他"]
	}, {
		type: 4,
		text: '网络',
		content: ["联通3G", "双卡单4G", "双卡双4G", "联通4G", "电信4G", "移动4G"]
	}];

	//=>需要操作的元素
	let $typeBox = $('#type'),
		$chooseBox = $('#choose');

	//=>根据数据渲染视图
	function render() {
		//=>待选区
		let str = ``;
		_DATA.forEach(item => {
			let {
				type,
				text,
				content
			} = item;
			str += `<li _type="${type}">
				${text}：
				${content.map(A=>{
					return `<a href="javascript:;">${A}</a>`;
				}).join('')}
			</li>`;
		});
		$typeBox.html(str);

		//=>选择区（绑定之前先根据TYPE排序）
		str = `你的选择:`;
		_SELECT.sort((A, B) => A.type - B.type);
		_SELECT.forEach(item => {
			str += `<mark>
				${item.name}
				<a href="javascript:;" _type="${item.type}">X</a>
			</mark>`;
		});
		$chooseBox.html(str);

		//=>渲染完绑定事件
		handle();
		handleSelect();
	}

	//=>待选取绑定点击事件
	function handle() {
		$typeBox.find('a').click(function () {
			let $this = $(this),
				obj = {};
			//=>构建存储的内容
			obj.type = parseFloat($this.parent().attr('_type'));
			obj.name = $this.text().trim();

			//=>点击谁就把谁存储到_SELECT中
			//1.存储之前，先看看原有数组中是否存在TYPE和当前存储这一项相同的，有相同的就要干掉它（同一个类别只能存储一个）
			_SELECT.forEach((item, index) => {
				if (item.type === obj.type) {
					_SELECT.splice(index, 1);
				}
			});
			_SELECT.push(obj);

			//=>重新渲染
			render();
		});
	}

	//=>已选区绑定点击事件
	function handleSelect() {
		//=>点击的时候在_SELECT中删除这一项
		$chooseBox.find('a').click(function () {
			let $this = $(this),
				_type = parseFloat($this.attr('_type'));
			_SELECT.forEach((item, index) => {
				if (item.type === _type) {
					_SELECT.splice(index, 1);
				}
			});
			render();
		});
	}

	return {
		init() {
			render();
		}
	}
})();
filterModule.init();
~~~

![数据驱动](C:\Users\左海之浅\Desktop\课程笔记\图片文件\数据驱动-1566266706848.png)

### 案例：多张图片延迟加载

```HTML
/*delaylmg*/
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>图片的延迟加载</title>
	<style>
		* {
			margin: 0;
			padding: 0;
		}

		.container {
			margin: 0 auto;
			width: 800px;
		}

		.imgBox {
			margin-bottom: 20px;
			height: 160px;
			background: #BBB;
			overflow: hidden;
		}

		.imgBox img {
			display: none;
			width: 100%;
		}
	</style>
</head>

<body>
	<div class="container">
		<!-- <div class="imgBox">
			<img src="" alt="" data-img="http://www.Zero.cn/main/img/banner10.png">
		</div> -->
	</div>


	<!-- IMPORT JS -->
	<script src="node_modules/jquery/dist/jquery.min.js"></script>
	<script src="delayImg.js"></script>
</body>

</html>
```

```js
/* let $imgBox = $('.imgBox'),
	$img = $imgBox.children('img'),
	$window = $(window);

//=>JQ中的事件绑定支持多事件绑定：window.onload & window.onscroll 两个事件触发的时候执行相同的事情
$window.on('load scroll', function () {
	if ($img.attr('isLoad') === 'true') {
		//=>之前加载过则不会重新加载
		return;
	}
	let $A = $imgBox.outerHeight() + $imgBox.offset().top,
		$B = $window.outerHeight() + $window.scrollTop();
	if ($A <= $B) {
		//=>加载真实图片
		$img.attr('src', $img.attr('data-img'));
		$img.on('load', function () {
			//=>加载成功：fadeIn是JQ中的渐现动画
			// $img.css('display', 'block');
			$img.stop().fadeIn();
		});
		$img.attr('isLoad', true); //=>ATTR存储的自定义属性值都是字符串"true"
	}
}); */

let $container = $('.container'),
	$imgBoxs = null,
	$window = $(window);

//=>造点假数据 new Array(20).fill(null)创建长度为20的数组，每一项用null填充
let str = ``;
new Array(20).fill(null).forEach(item => {
	str += `<div class="imgBox">
		<img src="" alt="" data-img="http://www.Zero.cn/main/img/banner10.png">
	</div>`;
});
$container.html(str);
$imgBoxs = $container.children('.imgBox');

//=>多张图片延迟加载
$window.on('load scroll', function () {
	//$B:获取浏览器底边框距离BODY的距离
	let $B = $window.outerHeight() + $window.scrollTop();
	//循环每一个图片区域，根据自己区域距离BODY的距离，计算出里面的图片是否加载
	$imgBoxs.each((index, item) => {
		let $item = $(item),
			$itemA = $item.outerHeight() + $item.offset().top,
			isLoad = $item.attr('isLoad');
		if ($itemA <= $B && isLoad !== 'true') {
			$item.attr('isLoad', true);
			//加载当前区域中的图片
			let $img = $item.children('img');
			$img.attr('src', $img.attr('data-img'));
			$img.on('load', () => $img.stop().fadeIn());
		}
	});
});
```

![delayImg](C:\Users\左海之浅\Desktop\课程笔记\图片文件\delayImg.png)

## 面试题.HTML5/CSS3/原生JS综合复习（1）

### 一、HTML5 / CSS3部分

1. 介绍一下BFC及其应用，IFC、GFC 和 FFC你都了解吗？

2. 怎么让一个 div 水平垂直居中

3. 分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景

4. 已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。

   ```html
   <img src="1.jpg" style="width:480px!important;”>
   ```

5. 用CSS实现三栏布局 ，左定右定中间自适应？ 

6. 使用CSS，让一个div消失在视野中，发挥想象力 ？

7. 如何用css绘制一个三角(不允许使用图片)？ 

8. css有哪些盒子模型？它们对应的样式是什么？如何让IE以标准模型渲染？

9. CSS优先级算法如何计算？

10. 请解释一下CSS3的flexbox（弹性盒布局模型）,以及适用场景？ 

### 二、JAVASCRIPT部分

1. call 和 apply 的区别是什么，哪个性能更好一些

2. 实现 (5).add(3).minus(2) ，使其输出结果为：6

3. 箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？

4. 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC' 变成 'aBc' 

5. 实现一个字符串匹配算法，从字符串 S 中，查找是否存在字符串 T，若存在返回所在位置，不存在返回-1！（如果不能基于indexOf/includes等内置的方法，你会如何处理呢？）

6. 输出下面代码运行结果

   ```javascript
   //example 1
   var a={}, b='123', c=123;  
   a[b]='b';
   a[c]='c';  
   console.log(a[b]);
   
   ---------------------
   //example 2
   var a={}, b=Symbol('123'), c=Symbol('123');  
   a[b]='b';
   a[c]='c';  
   console.log(a[b]);
   
   ---------------------
   //example 3
   var a={}, b={key:'123'}, c={key:'456'};  
   a[b]='b';
   a[c]='c';  
   console.log(a[b]);
   ```

7. 在输入框中如何判断输入的是一个正确的网址，例如：用户输入一个字符串，验证是否符合URL网址的格式

8. 下面代码输出的结果

   ```javascript
   function Foo() {
       Foo.a = function() {
           console.log(1)
       }
       this.a = function() {
           console.log(2)
       }
   }
   Foo.prototype.a = function() {
       console.log(3)
   }
   Foo.a = function() {
       console.log(4)
   }
   Foo.a();
   let obj = new Foo();
   obj.a();
   Foo.a();
   ```

9. 编写代码实现图片的懒加载

10. 编写一条正则，用来验证此规则：一个6~16位的字符串，必须同时包含有大小写字母和数字

11. 完成如下需求

    ```javascript
    /* 实现一个$attr(name,value)遍历
     * 属性为name
     * 值为value的元素集合
     * 
     * 例如下面示例:
     */
    let ary = $attr('class','box'); //=>获取页面中所有class为box的元素
    ```

12. 英文字母汉字组成的字符串，用正则给英文单词前后加空格

### 三、烧脑的算法题（注意不要揪头发）(\*^▽^\*)

1. 算法题（携程）

   ```javascript
   /*编写一个程序，将数组扁平化，并去除其中重复部分数据，最终得到一个升序且不重复的数组*/
   let arr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9,[11, 12, [12, 13, [14]]]], 10];
   ```

2. 情人节福利题：重构内置new方法

   ```javascript
   function Dog(name) {
   	this.name = name;
   }
   Dog.prototype.bark = function () {
   	console.log('wangwang');
   }
   Dog.prototype.sayName = function () {
   	console.log('my name is ' + this.name);
   }
   /*
   let sanmao = new Dog('三毛');
   sanmao.sayName();
   sanmao.bark();
   */
   //=>基于内置的new关键词，我们可以创建Dog的一个实例sanmao，实例可以调取原型上的属性和方法，现在的需求是：自己实现一个_new方法，也能模拟出内置new后的结果
   function _new() {
   	//=>完成你的代码
   	
   }
   let sanmao = _new(Dog, '三毛');
   sanmao.bark(); //=>"wangwang"
   sanmao.sayName(); //=>"my name is 三毛"
   console.log(sanmao instanceof Dog); //=>true
   ```

3. 两个数组和并为一个数组

   ```javascript
   let ary1 = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];
   let ary2 = ['A', 'B', 'C', 'D']; 
   //=>合并后的数组为：['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']
   ```

4. 改造下面代码，使之输出0-9

   ```javascript
   for (var i = 0; i < 10; i++) {
   	setTimeout(() => {
   		console.log(i);
   	}, 1000);
   }
   ```

5. 下面代码输出的结果是多少，为什么？如何改造一下，就能让其输出 20 10？

   ```javascript
   var b = 10;
   (function b() {
   	b = 20;
   	console.log(b);
   })();
   console.log(b);
   ```

6. 下面代码a在什么值情况下会输出1

   ```javascript
   var a = ?;
   if (a == 1 && a == 2 && a == 3) {
   	console.log(1);
   }
   ```

7. 下面代码的输出结果？为什么？

   ```javascript
   let obj = {
   	2: 3,
   	3: 4,
   	length: 2,
   	push: Array.prototype.push
   }
   obj.push(1);
   obj.push(2);
   console.log(obj);
   ```

8. 冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？

9. 完成如下需求

   ```javascript
   /* 
   某公司1到12月份的销售额存在一个对象里面
   如下： {
   	1: 222,
   	2: 123,
   	5: 888
   }，
   请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null] 
   */
   ```

10. 给定两个数组， 写一个方法来计算它们的交集

    ```javascript
    let nums1 = [1, 2, 2, 1];
    let nums2 = [2, 2];
    //=> 输出结果 [2,2]
    ```

11. 算法题「旋转数组」

    ```javascript
    /* 
    给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数
    输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
    输出: [5, 6, 7, 1, 2, 3, 4]
    解释:
    向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]
    向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]
    向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]
    
    输入: [-1, -100, 3, 99] 和 k = 2
    输出: [3, 99, -1, -100]
    解释: 
    向右旋转 1 步: [99, -1, -100, 3]
    向右旋转 2 步: [3, 99, -1, -100] 
    */
    ```

12. 请实现一个 add 函数，满足以下功能

    ```javascript
    add(1);       //1
    add(1)(2);    //3
    add(1)(2)(3); //6
    add(1)(2,3);  //6
    add(1,2)(3);  //6
    add(1,2,3);   //6
    ```

### 解答~~~

~~~js
/* 1.call 和 apply 的区别是什么，哪个性能更好一些？ */
// fn.call(obj,10,20,30);
// fn.apply(obj,[10,20,30]);
//=>call的性能要比apply好那么一些（尤其是传递给函数的参数超过三个的时候），所以后期开发的时候，可以使用call多一点
// let arr = [10, 20, 30],
// 	obj = {};
// function fn(x, y, z) {}
// fn.apply(obj, arr); //=>x=10 y=20 z=30
// fn.call(obj, arr); //=>x=[10,20,30] y=z=undefined
// fn.call(obj, ...arr); //=>基于ES6的展开运算符也可以实现把数组中的每一项依次传递给函数
//=>自己实现性能测试（只供参考）：任何的代码性能测试都是和测试的环境有关系的，例如CPU、内存、GPU等电脑当前性能不会有相同的情况，不同浏览器也会导致性能上的不同；
//console.time()可以测试出一段程序执行的时间
//console.profile()在火狐浏览器中安装FireBug，可以更精准的获取到程序每一个步骤所消耗的时间
// console.time('A');
// for (let i = 0; i < 100000000; i++) {

// }
// console.timeEnd('A');

/* 实现 (5).add(3).minus(2) ，使其输出结果为：6 */
/* ~ function () {
	//=>每一个方法执行完，都要返回NUMBER这个类的实例，这样才可以继续调取NUMBER类原型中的方法（链式写法）
	function check(n) {
		n = Number(n);
		return isNaN(n) ? 0 : n;
	}

	function add(n) {
		n = check(n);
		return this + n;
	}

	function minus(n) {
		n = check(n);
		return this - n;
	}

	Number.prototype.add = add;
	Number.prototype.minus = minus;
	/!* ["add", "minus"].forEach(item => {
		Number.prototype[item] = eval(item);
	}); *!/
}();
console.log((5).add(3).minus(2)); */

/* 箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？ */
/*
 * 箭头函数和普通函数的区别
 *   1.箭头函数语法上比普通函数更加简洁（ES6中每一种函数都可以使用形参赋默认值和剩余运算符）
 *   2.箭头函数没有自己的THIS，它里的THIS是继承函数所处上下文中的THIS（使用CALL/APPY等任何方式都无法改变THIS的指向）
 *   3.箭头函数中没有ARGUMENTS（类数组），只能基于...ARG获取传递的参数集合（数组）
 *   4.箭头函数不能被new执行（因为：箭头函数没有this也没有prototype）
 */
/* function Fn() {
	this.x = 100;
}
Fn.prototype.getX = function () {};
let f = new Fn; */

// let Fn = () => {
// 	this.x = 200;
// };
// let f = new Fn; //=>Uncaught TypeError: Fn is not a constructor


// function fn(x) {
// 	return function (y) {
// 		return x + y;
// 	}
// }
// let fn = x => y => x + y;

// let obj = {
// 	name: 'OBJ'
// };
// function fn1() {
// 	console.log(this);
// }
// fn1.call(obj);
// let fn2 = () => {
// 	console.log(this);
// };
// fn2.call(obj);

// document.body.onclick = () => {
// 	//=>THIS:WINDOW 不是当前操作的BODY了
// };
// document.body.onclick = function () {
// 	//=>THIS:BODY
// 	// arr.sort(function (a, b) {
// 	// 	//=>THIS:WINDOWN 回调函数中的THIS一般都是WINDOW
// 	// 	return a - b;
// 	// });
// 	arr.sort((a, b) => {
// 		//=>THIS:BODY
// 		return a - b;
// 	});
// };

//=>回调函数：把一个函数B作为实参传递给另外一个函数A，函数A在执行的时候，可以把传递进来的函数B去执行（执行N次，可传值，可改THIS）
// function each(arr, callBack) {
// 	//=>callBack:function(item, index){}
// 	for (let i = 0; i < arr.length; i++) {
// 		let flag = callBack.call(arr, arr[i], i);
// 		//=>接受回调函数返回的结果，如果是FALSE，我们结束循环
// 		if (flag === false) {
// 			break;
// 		}
// 	}
// }
// each([10, 20, 30, 40], function (item, index) {
// 	//=>this:原始操作数组
// 	if (index > 1) {
// 		return false;
// 	}
// });

// let fn = (...arg) => {
// 	// console.log(arguments); //=>Uncaught ReferenceError: arguments is not defined
// 	console.log(arg);
// };
// fn(10, 20, 30);

/* 思考题？ */
// 1.each
/* let arr = [10, 20, 30, 'AA', 40],
	obj = {};
arr = arr.each(function (item, index) {
	//=>THIS:OBJ（EACH第二个参数不传，THIS是WINDOW即可）
	if (isNaN(item)) {
		return false;  //=>如果RETURN的是FALSE，则结束当前数组的循环
	}
	return item * 10; //=>返回的结果是啥，就把数组中当前项替换成啥
}, obj);
//arr=[100,200,300,'AA',40]; */

//2.replace 重写这个方法，实现和内置一模一样的效果（只需要考虑 replace([REG],[CALLBACK]) 这种传参格式的处理）
/* let str = "Zero2019Zero2029";
str = str.replace(/Zero/g, function (...arg) {
	//ARG中存储了每一次大正则匹配的信息和小分组匹配的信息
	return '@'; //=>返回的是啥把当前正则匹配的内容替换成啥
}); */
~~~

~~~js
/* 如何把一个字符串的大小写取反（大写变小写，小写变大写），例如 ’AbC' 变成 'aBc'  */
/* let str = "Zero很帅！吁*100！HAHA";
str = str.replace(/[a-zA-Z]/g, content => {
	//=>content:每一次正则匹配的结果
	//验证是否为大写字母：把字母转换为大写后看和之前是否一样，如果一样，之前也是大写的；在ASCII表中找到大写字母的取值范围进行判断（65-90）；
	// content.toUpperCase()===content
	// content.charCodeAt()>=65 && content.charCodeAt()<=90
	return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase();
});
console.log(str); */

/* 实现一个字符串匹配算法，从字符串 S 中，查找是否存在字符串 T，若存在返回所在位置，不存在返回-1！（如果不能基于indexOf/includes等内置的方法，你会如何处理呢？） */
~ function () {
	/*
	 * 循环原始字符串中的每一项，让每一项从当前位置向后截取T.length个字符，然后和T进行比较，如果不一样，继续循环；如果一样返回当前索引即可（循环结束）；
	 */
	/* function myIndexOf(T) {
		//=>THIS:S
		let lenT = T.length,
			lenS = this.length,
			res = -1;
		if (lenT > lenS) return -1;
		for (let i = 0; i <= lenS - lenT; i++) {
			if (this.substr(i, lenT) === T) {
				res = i;
				break;
			}
		}
		return res;
	} */

	/*
	 * 正则处理 
	 */
	function myIndexOf(T) {
		//=>THIS:S
		let reg = new RegExp(T),
			res = reg.exec(this);
		return res === null ? -1 : res.index;
	}

	String.prototype.myIndexOf = myIndexOf;
}();
// let S = "Zero",
// 	T = "pei";
// console.log(S.myIndexOf(T));

/* 输出下面代码运行结果 */
/* //example 1
var a={}, b='123', c=123;  
a[b]='b';
a[c]='c';  
console.log(a[b]); //=>c  因为：a["123"] <=> a[123]

//example 2
var a={}, b=Symbol('123'), c=Symbol('123');  
a[b]='b';
a[c]='c';  
console.log(a[b]);  //=>Symbol是ES6中新增的数据类型  typeof Symbol('123')==="symbol"  它创建出来的值是唯一值  Symbol('123')===Symbol('123'):FALSE

//example 3
var a={}, b={key:'123'}, c={key:'456'};  
a[b]='b';
a[c]='c';  
console.log(a[b]);
//1.对象的属性名不能是一个对象（遇到对象属性名，会默认转换为字符串）
// obj={}  arr=[12,23]  obj[arr]='珠峰'  obj=>{"12,23":"珠峰"}
//2.普通对象.toString() 调取的是Object.prototype上的方法（这个方法是用来检测数据类型的）
// obj={}  obj.toString()=>"[object Object]" 
// obj[b]='b'  => obj["[object Object]"]='b' */

/* 在输入框中如何判断输入的是一个正确的网址，例如：用户输入一个字符串，验证是否符合URL网址的格式 */
let str = "https://www.Zero.com.cn";
let reg = /^(?:(http|https|ftp):\/\/)?((?:[\w-]+\.)+[a-z0-9]+)((?:\/[^/?#]*)+)?(\?[^#]+)?(#.+)?$/i;
console.log(reg.exec(str));
//=>URL格式
//1.协议://  http/https/ftp
//2.域名
// www.Zero.cn
// Zero.cn
// kbs.sports.qq.com
// kbs.sports.qq.com.cn
//3.请求路径
// /
// /index.html
// /stu/index.html
// /stu/
//4.问号传参
// ?xxx=xxx&xxx=xxx
//5.哈希值
// #xxx
~~~

~~~js
/* function Foo() {
	Foo.a = function () {
		console.log(1)
	}
	this.a = function () {
		console.log(2)
	}
}
//=>把Foo当做类，在原型上设置实例公有的属性方法  => 实例.a();
Foo.prototype.a = function () {
	console.log(3)
}
//=>把Foo当做普通对象设置私有的属性方法  => Foo.a();
Foo.a = function () {
	console.log(4)
}
Foo.a(); //=>4
let obj = new Foo(); //=>obj可以调取原型上的方法  Foo.a:f=>1  obj.a:f=>2
obj.a(); //=>2 私有属性中有a
Foo.a(); //=>1 */

/* 
 * 编写代码实现图片的懒加载
 *   1.前端性能优化的重要方案
 *     + 通过图片或者数据的延迟加载，我们可以加快页面渲染的速度，让第一次打开页面的速度变快
 *     + 只有滑动到某个区域，我们才加载真实的图片，这样也可以节省加载的流量
 *     + ...
 *   2.处理方案
 *     + 把所有需要延迟加载的图片用一个盒子包起来，设置宽高和默认占位图
 *     + 开始让所有的IMG的SRC为空，把真实图片的地址放到IMG的自定义属性上，让IMG隐藏
 *     + 等到所有其它资源都加载完成后，我们再开始加载图片
 *     + 对于很多图片，需要当页面滚动的时候，当前图片区域完全显示出来后再加载真实图片
 *     + ...
 */

/* 编写一条正则，用来验证此规则：一个6~16位的字符串，必须同时包含有大小写字母和数字 */
// let reg = /(?!^[a-zA-Z]+$)(?!^[0-9]+$)(?!^[a-z0-9]+$)(?!^[A-Z0-9]+$)^[a-zA-Z0-9]{6,16}$/;

/* 1-10位：数字、字母、下划线组成字符串，必须有_ */
// let reg = /(?!^[a-zA-Z0-9]+$)^\w{1,10}$/;

/* 字符串中包含 “\w”，但是必须包含_ */
// let reg = /(?=_)\w+/;


/* 实现一个$attr(name,value)遍历
 * 属性为name
 * 值为value的元素集合
 * 
 * 例如下面示例:
 */
/* function $attr(property, value) {
	//=>获取当前页面中所有的标签
	let elements = document.getElementsByTagName('*'),
		arr = [];
	// [].forEach.call(elements, item => {});
	elements = Array.from(elements); //=>把非数组转换为数组
	elements.forEach(item => {
		//=>存储的是当前元素PROPERTY对应的属性值
		let itemValue = item.getAttribute(property);
		if (property === 'class') {
			//=>样式类属性名要特殊的处理
			new RegExp("\\b" + value + "\\b").test(itemValue) ? arr.push(item) : null;
			return;
		}
		if (itemValue === value) {
			//=>获取的值和传递的值校验成功：当前就是我们想要的
			arr.push(item);
		}
	});
	return arr;
}
console.log($attr('class', 'box')); */

/* 英文字母汉字组成的字符串，用正则给英文单词前后加空格 */
// let str = "no作no死，你能你can，不能no哔哔！",
// 	reg = /\b[a-z]+\b/ig;
// str = str.replace(reg, value => {
// 	return " " + value + " ";
// }).trim();//=>String.prototype.trim/.trimLeft/.trimRight 去除字符串首尾空格
// console.log(str);
~~~

~~~js
/* https://developer.mozilla.org/en-US/docs/Web/JavaScript */
/*编写一个程序，将数组扁平化，并去除其中重复部分数据，最终得到一个升序且不重复的数组*/
let arr = [
	[1, 2, 2],
	[3, 4, 5, 5],
	[6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10
];

//=>使用ES6中提供的 Array.prototype.flat 处理
// arr = arr.flat(Infinity);

//=>把数组直接变为字符串即可（数组TOSTRING之后，不管你有多少级，最后都会变为以逗号分隔的字符串，没有中括号和所谓的层级了），相当于直接的扁平化了
// arr = arr.toString().split(',').map(item => {
// 	return Number(item);
// });

//=>JSON.stringify也可以扁平化数组
// JSON.stringify(arr) : "[[1,2,2],[3,4,5,5],[6,7,8,9,..."
// replace(/(\[|\])/g, '') : "1,2,2,3,4,5,5,6,7,8,9..."
// arr = JSON.stringify(arr).replace(/(\[|\])/g, '').split(',').map(item => Number(item));

//=>基于数组的some方法进行判断检测：验证数组中的某一项有没有符合函数中提供的规则的
//=>find和some的区别：some返回的是boolean，find找到符合规则的，返回当前这一项，没找到符合规则的，返回undefined
//=>Array.isArray([val])：检测某个值是否为数组类型（挺准的）
/* var A = [2, 3, 4, 5];
var B = A.find(item => {
	return item < 6;
});
console.log(B); */
// while (arr.some(item => Array.isArray(item))) {
// 	arr = [].concat(...arr);
// }

//=>自己递归处理
~ function () {
	function myFlat() {
		let result = [],
			_this = this;
		//=>循环ARR中的每一项，把不是数组的存储到新数组中
		let fn = (arr) => {
			for (let i = 0; i < arr.length; i++) {
				let item = arr[i];
				if (Array.isArray(item)) {
					fn(item);
					continue;
				}
				result.push(item);
			}
		};
		fn(_this);
		return result;
	}
	Array.prototype.myFlat = myFlat;
}();
arr = arr.myFlat();



//=>基于ES6中的new Set()去重数组（也可以自己写方法）
// [...new Set(arr)]
// Array.from(new Set(arr))
arr = Array.from(new Set(arr)).sort((a, b) => a - b);
console.log(arr);
~~~

~~~js
function Dog(name) {
	this.name = name;
}
Dog.prototype.bark = function () {
	console.log('wangwang');
}
Dog.prototype.sayName = function () {
	console.log('my name is ' + this.name);
}
//=>Fn当前要NEW的类  =>Dog
//=>ARG后期需要给构造函数传递的参数信息  =>['三毛']
function _new(Fn, ...arg) {
	//=>创建一个空对象，让他的原型链指向Fn.prototype（作为Fn的一个实例）
	//=>Object.create([AA对象])：创建一个空对象obj，并且让空对象obj作为AA对象所属构造函数的实例（obj.__proto__=AA）
	// let obj = {};
	// obj.__proto__ = Fn.prototype;
	let obj = Object.create(Fn.prototype);
	Fn.call(obj, ...arg);
	return obj;
}
let sanmao = _new(Dog, '三毛');
/* 
 * let sanmao=new Dog('三毛'); 
 *   1.像普通函数执行一样，形成一个私有的作用域
 *     + 形参赋值
 *     + 变量提升
 *   2.默认创建一个对象,让函数中的this执行这个对象,这个对象就是当前类的一个实例
 *   3.代码执行
 *   4.默认把创建的对象返回
 */

//=>基于内置的new关键词，我们可以创建Dog的一个实例sanmao，实例可以调取原型上的属性和方法，现在的需求是：自己实现一个_new方法，也能模拟出内置new后的结果
// function _new() {
// 	//=>完成你的代码
// }
sanmao.bark(); //=>"wangwang"
sanmao.sayName(); //=>"my name is 三毛"
console.log(sanmao instanceof Dog); //=>true
~~~

~~~js
let ary1 = ['D1', 'D2', 'A1', 'A2', 'C1', 'C2', 'B1', 'B2'];
let ary2 = ['B', 'A', 'D', 'C'];
//=>合并后的数组为：['D1', 'D2','D', 'A1', 'A2','A', 'C1', 'C2','C' ,'B1', 'B2','B']
/* ary2 = ary2.map(item => item + '珠峰');
let arr = ary1.concat(ary2);
arr = arr.sort((a, b) => a.localeCompare(b)).map(item => {
	return item.replace('珠峰', '');
});
console.log(arr); */

/* let n = 0;
for (let i = 0; i < ary2.length; i++) {
	let item2 = ary2[i];
	for (let k = 0; k < ary1.length; k++) {
		let item1 = ary1[k];
		if (item1.includes(item2)) {
			//=>如果包含就记录一下当前这一项的索引位置（后面还有包含的会重新记录这个值）
			n = k;
		}
	}
	//=>把当前ITEM2这一项插入到ARY1中N的后面
	ary1.splice(n + 1, 0, item2);
}
console.log(ary1); */

//=>定时器是异步编程：每一轮循环设置定时器，无需等定时器触发执行，继续下一轮循环（定时器触发的时候，循环已经结束了）
/* for (let i = 0; i < 10; i++) {
	//=>LET存在块级作用域，每一次循环都会在当前块作用域中形成一个私有变量i存储0~9
	//当定时器执行的时候，所使用的i就是所处块作用域中的i
	setTimeout(() => {
		console.log(i);
	}, 1000);
} */

//=>闭包解决
/* for (var i = 0; i < 10; i++) {
	~ function (i) {
		setTimeout(() => {
			console.log(i);
		}, 1000);
	}(i);
} */
/* for (var i = 0; i < 10; i++) {
	setTimeout((i => () => console.log(i))(i), 1000);
} */

//=>可以基于bind的预先处理机制：在循环的时候就把每次执行函数需要输出的结果，预先传给函数即可
/* var fn = function (i) {
	console.log(i);
};
for (var i = 0; i < 10; i++) {
	setTimeout(fn.bind(null, i), 1000);
} */

/* var b = 10;
(function b() {
	b = 20;
	console.log(b); //=>函数
})();
console.log(b); //=>10 */

/* let fn = function AAA() {
	// "use strict";
	// AAA = 1000; //=>Uncaught TypeError: Assignment to constant variable.
	console.log(AAA); //=>当前函数
};
// AAA(); //=>Uncaught ReferenceError: AAA is not defined  
// 1.本应匿名的函数如果设置了函数名，在外面还是无法调用，但是在函数里面是可以使用的
// 2.而且类似于创建常量一样，这个名字存储的值不能再被修改（非严格模式下不错报，但是不会有任何的效果，严格模式下直接报错，我们可以把AAA理解为是用 const 创建出来的）
fn(); */

/* var b = 10;
(function b(b) {
	b = 20;
	console.log(b); //=>20 里面的b一定需要是私有的，不能是全局的（声明它或者改为形参）
})();
console.log(b); //=>10 */
~~~

~~~js
/*
 * ==进行比较的时候，如果左右两边数据类型不一样，则先转换为相同的数据类型，然后在进行比较
 *   1. {}=={} 两个对象进行比较，比较的是堆内存的地址
 *   2. null==undefined 相等的  / null===undefined 不相等
 *   3. NaN==NaN 不相等  NaN和谁都不相等
 *   4. [12]=="12"  对象和字符串比较，是把对象toString()转换为字符串后再进行比较的
 *   5. 剩余所有情况在进行比较的时候，都是转换为数字（前提数据类型不一样）
 *      	对象转数字：先转换为字符串，然后再转换为数字
 *      	字符串转数字：只要出现一个非数字字符，结果就是NaN
 *      	布尔转数字：true->1  false->0
 *      	null转数字0
 *      	undefined转数字NaN
 *      [12]==true   => Number([12].toString())==1  false
 *      []==false    => 0==0   true
 *      []==1        => 0==1   false
 *      "1"==1       => 1==1   true
 *      true==2      => 1==2   false
 * .....
 */

//=>对象和数字比较：先把对象.toString()变为字符串，然后再转换为数字
/* var a = {
	n: 0,
	//=>私有的属性方法
	toString: function () {
		return ++this.n;
	}
};
// a.toString(); //=>此时调取的就不再是Object.prototype.toString了，调取的是自己私有的
if (a == 1 && a == 2 && a == 3) {
	console.log('OK');
} */

//=>shift:删除数组第一项，把删除的内容返回，原有数组改变
// let a = [1, 2, 3];
// a.toString = a.shift;
// if (a == 1 && a == 2 && a == 3) {
// 	console.log('OK');
// }


/*
 * ES6中新增加的一些方法
 *   String.fromCharCode([n])  <=> "z".charCodeAt()  
 *   Array.from()
 *   Array.isArray() 
 *   Object.create([OBJ])
 *   Object.defineProperty()
 */
/* let obj = {};
Object.defineProperty(obj, 'name', {
	get: function () {
		console.log('哈哈');
		return "珠峰培训";
	},
	set: function () {
		console.log('呵呵呵');
		this.value = "呵呵呵";
	}
}); */

/* Object.defineProperty(window, 'a', {
	get: function () {
		//=>this:window.a
		this.value ? this.value++ : this.value = 1;
		return this.value;
	}
});
if (a == 1 && a == 2 && a == 3) {
	console.log('OK');
} */


/* Array.prototype.push = function @@(val) {
	this[this.length] = val;
	//=>this.length在原来的基础上加1
	return this.length;
}*/
/* let obj = {
	2: 3, //=>1
	3: 4, //=>2
	length: 2, //=>3/4
	push: Array.prototype.push
}
obj.push(1);
//=>@@(1)  //=>this:obj  //=>obj[obj.length]=1  //=>obj[2]=1  //=>obj.length=3
obj.push(2);
//=>@@(2)  //=>this:obj  //=>obj[obj.length]=2  //=>obj[3]=2  //=>obj.length=4
console.log(obj); */

/* 
某公司1到12月份的销售额存在一个对象里面
如下： {
    1: 222,
    2: 123,
    5: 888
}，
请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null] 
*/
// let obj = {
// 	1: 222,
// 	2: 123,
// 	5: 888
// };
// let arr = new Array(12).fill(null).map((item, index) => {
// 	return obj[index + 1] || null;
// });
// console.log(arr);

// let obj = {
// 	1: 222,
// 	2: 123,
// 	5: 888
// };
// obj.length = 13;
// let arr = Array.from(obj).slice(1).map(item => {
// 	return typeof item === "undefined" ? null : item;
// });
// console.log(arr);

/* let obj = {
	1: 222,
	2: 123,
	5: 888
};
//=>Object.keys(obj):获取obj中所有的属性名，以数组的方式返回
// console.log(Object.keys(obj)); //=>["1","2","5"]
let arr = new Array(12).fill(null);
Object.keys(obj).forEach(item => {
	arr[item - 1] = obj[item];
});
console.log(arr); */

//Array.prototype
//push/pop/shift/unshift/splice/slice/concat/join/toString/reverse/sort/indexOf/lastIndexOf/includes/forEach/map/some/find/flat/fill....

/* 给定两个数组， 写一个方法来计算它们的交集   思考题：交差并补?*/
/* let nums1 = [12, 23, 34, 23, 45, 34, 25, 46, 35];
let nums2 = [10, 35, 24, 23, 36, 47, 56];
let arr = [];
nums1.forEach((item, index) => {
	//=>index是第一个数组当前项的索引
	//=>n当前项在第二个数组中找到相同那一项的索引
	let n = nums2.indexOf(item);
	if (n >= 0) {
		arr.push(item);
		nums1.splice(index, 1);
		nums2.splice(n, 1);
	}
}); */
/* for (let i = 0; i < nums1.length; i++) {
	let item1 = nums1[i];
	for (let k = 0; k < nums2.length; k++) {
		let item2 = nums2[k];
		if (item1 === item2) {
			arr.push(item1);
			break;
		}
	}
} */
// console.log(arr);

/* 
旋转数组
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数
输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
输出: [5, 6, 7, 1, 2, 3, 4]
解释:
向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]
向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]
向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]

输入: [-1, -100, 3, 99] 和 k = 2
输出: [3, 99, -1, -100]
解释: 
向右旋转 1 步: [99, -1, -100, 3]
向右旋转 2 步: [3, 99, -1, -100] 
*/
/* function rotate(k) {
	//=>参数处理
	if (k < 0 || k === 0 || k === this.length) return this;
	if (k > this.length) k = k % this.length;
	//=>旋转数组
	// return this.slice(-k).concat(this.slice(0, this.length - k));
	// return [...this.splice(this.length - k), ...this];

	/!* for (let i = 0; i < k; i++) {
		this.unshift(this.pop());
	} *!/
	new Array(k).fill('').forEach(() => this.unshift(this.pop()));
	return this;
}
Array.prototype.rotate = rotate;

let arr = [1, 2, 3, 4, 5, 6, 7];
console.log(arr.rotate(3)); */
~~~

~~~js
/* 函数柯理化：预先处理的思想（利用闭包的机制） */
/* function fn(x){
	//=>预先在闭包中把X值存储起来
	return function(y){
		return x+y;
	}
}
fn(100)(200) */
/* (function () {
	//=>this:需要改变THIS的函数
	//=>context:需要改变的THIS指向
	//=>outerArg:其余需要传递给函数的实参信息
	function myBind(context = window, ...outerArg) {
		let _this = this; 
		return function anonymous(...innerArg) {
			_this.call(context, ...outerArg.concat(innerArg));
		}
	}
	Function.prototype.myBind = myBind;
})();

let obj = {
	name: 'OBJ'
};

function fn(...arg) {
	console.log(this, arg);
}
document.body.onclick = fn.myBind(obj, 100, 200);;
 */
//=>点击的时候FN中的this=>obj arg=>[100,200,事件对象]
// document.body.onclick = fn.bind(obj, 100, 200);
// document.body.onclick = function (ev) {
// 	fn.call(obj, 100, 200, ev);
// }
//=>执行bind方法，会返回一个匿名函数，当事件触发，匿名函数执行，我们再处理fn即可


// document.body.onclick = fn; //=>this:BODY  arg:[事件对象]
/* document.body.onclick = function (ev) {
	//=>ev事件对象：给元素的某个事件绑定方法，当事件触发会执行这个方法，并且会把当前事件的相关信息传递给这个函数“事件对象”
	console.log(ev);
} */




/* 请实现一个 add 函数，满足以下功能 */
// add(1); //1
// add(1)(2); //3
// add(1)(2)(3); //6
// add(1)(2)(3)(4); //10
// add(1)(2, 3); //6
// add(1, 2)(3); //6
// add(1, 2, 3); //6

function currying(fn, length) {
	length = length || fn.length;
	return function (...args) {
		if (args.length >= length) {
			return fn(...args);
		}
		return currying(fn.bind(null, ...args), length - args.length);
	}
}
let add = currying((...arg) => eval(arg.join('+')), 5);
console.log(add(1, 2, 3, 4, 5));
console.log(add(1, 2)(3, 4, 5));
console.log(add(1, 2)(3, 4)(5));
console.log(add(1, 2)(3)(4)(5));
console.log(add(1)(2)(3)(4)(5));

/* function add(...A) {
	return function (...B) {
		return function (...C) {
			return eval([...A, ...B, ...C].join('+'));
		}
	}
}
add(1)(2)(3); */

// function $add(n1, n2, n3, n4) {
// 	return n1 + n2 + n3 + n4;
// }
// add = currying($add, 4);
// console.log(add(1, 2, 3, 4));
// console.log(add(1)(2)(3)(4)); 
//=>$add.bind(null,1).bind(null,2).bind(null,3)(4)
// function anonymous1(...innerArg){ $add.call(null,...[1,...innerArg]) }
// function anonymous2(...innerArg){ anonymous1.call(null,...[2,...innerArg])}
// function anonymous3(...innerArg){ anonymous2.call(null,...[3,...innerArg])}
// anonymous3(4) 
// 往回推
// anonymous2.call(null,3,4)
// anonymous1.call(null,2,3,4)
// $add.call(null,1,2,3,4)
// console.log(add(1, 2)(3, 4));
~~~

![curring](C:\Users\左海之浅\Desktop\课程笔记\图片文件\curring-1566456016651.png)

## 面试题.原生JS综合复习（2）

**01.**  下面代码的输出结果

```javascript
var a = 'abc' + 123 + 456;
alert(a);

var b = '456' - '123';
alert(b);

var c = 1,
	d = '1';
var f = c > d ? (c < d ? c : d) : (c == d ? c : d);
alert(f);
```

```javascript
var str = 'abc123',
	num = parseFloat(str);
if (num === NaN) {
	alert(NaN);
} else if (num === 123) {
	alert(123);
} else if (typeof num === 'number') {
	alert('number');
} else {
	alert('str');
}
```

**02.** 写出下面代码输出的结果

```javascript
let point = {
	x: 10,
	y: 20,
	moveTo: function (x, y) {
		let moveX = function (x) {
			this.x = x;
		}
		let moveY = function (y) {
			this.y = y;
		}
		moveX(x);
		moveY(y);
	}
};
point.moveTo(100, 200);
console.log(point.x, point.y);
```

**03. ** 请说出你对 “重排和重绘读写分离” 的理解！

**04.**  JS中有一个insertBefore方法，目的是实现把新元素插入到指定元素之前，现在你实现一个 insertAfter 方法，把新元素插入到指定元素之后！

```javascript
function insertAfter(newEle, originEle) {
	//=>newEle:新插入的元素
	//=>originEle:指定的老元素
}
```

**05.** 编写一个函数,把一个列表中的每一项反序

```html
<ul id='target'>
	<li>1</li>
	<li>2</li>
	<li>3</li>
	<li>4</li>
	<li>5</li>
</ul>
```

**06.** jQuery的原理，怎么扩展插件

**07.** 使用JQ实现点击按钮弹出一个对话框（对话框在整个页面正中间，并且最初页面中没有任何的HTML标签）

**08. ** 写出你掌握的JS继承方式，项目中什么时候你用到了继承？

**09.** 完成如下需求

```javascript
//=>toChineseChar这个函数可以把阿拉伯数字转换为大写的中文数字汉字
"54389".toChineseChar(); //=>”伍肆叁捌玖”
```

**10.** 完成如下需求

```javascript
//=>在javascript对象上定义一个repeatify函数,这个函数接受一个整数参数,来明确子字符串需要重复几次
"abc".repeatify(3); //=>"abcabcabc"
```

**11.** 完成如下需求

```javascript
let str = 'hello<img src="haha.png" alt="哈哈"/>world';
//=>正确匹配输出 "hello[哈哈]world"
```

**12.** 写出完整的验证函数:长度不能小于6位，首字母必须是字母，合法字符只能是数字、字母、下划线

**13.** 完成如下需求

```javascript
/* 
	在函数式编程当中有一个很重要的概念就是函数组合， 实际上就是把处理数据的函数像管道一样连接起来， 然后让数据穿过管道得到最终的结果。 例如：
	const add1 = (x) => x + 1;
	const mul3 = (x) => x * 3;
	const div2 = (x) => x / 2;
	div2(mul3(add1(add1(0)))); //=>3

	而这样的写法可读性明显太差了，我们可以构建一个compose函数，它接受任意多个函数作为参数（这些函数都只接受一个参数），然后compose返回的也是一个函数，达到以下的效果：
	const operate = compose(div2, mul3, add1, add1)
	operate(0) //=>相当于div2(mul3(add1(add1(0)))) 
	operate(2) //=>相当于div2(mul3(add1(add1(2))))

	简而言之：compose可以把类似于f(g(h(x)))这种写法简化成compose(f, g, h)(x)，请你完成 compose函数的编写 
*/
```

**14.** 完成如下需求

```javascript
/* 
	[结构]
	<ul>
		<li><a href='http://xxx'>xxx</a></li>
		<li><a href='http://sss'>sss</a></li>
	</ul> 
	点击第一个LI创建对象： 
	{
		index: 1,
		name: 'xxx',
		link: 'http://xxx'
	}
	同样点击第二个LI创建对象 
	{
		index: 2,
		name: 'sss,
		link: 'http://sss'
	}
*/
```

**15.** 补全1/2处的代码实现如下需求

```javascript
function fn(str) {
	this.str = str;
}
fn.prototype.format = function () {
	let arg = __1__;
	return this.str.replace(__2__, (a, b) => {
		return arg[b] || '';
	});
};
let t = new fn(`<p>
	<a href="{0}">{1}</a>
	<span>{2}</span>
</p>`);
let HTML = t.format("http://www.alibaba.com", "Alibaba", "welcome");
// console.log(HTML); => "<p><a href="http://www.alibaba.com">Alibaba</a><span>welcome</span></p>"
```





