# 第四周

## 二十五.定时器

> 浏览器中的定时器有两种：设置一个定时器，规定在等待时间之后执行某个方法
>
> - setTimeout：执行一次
> - setInterval：一直会执行下去（每间隔这么长时间都会执行）

~~~html
<body>
	<input type="button" value="暂停" id="handleTimer">


	<script>
		let handleTimer = document.getElementById('handleTimer'),
			timer = null,
			count = 0;

		function createTimer() {
			timer = setInterval(() => {
				count++;
				console.log(count);
			}, 1000);
		}
		createTimer();

		handleTimer.onclick = function () {
			if (timer) {
				//=>TIMER存在说明有定时器在执行，我们让其暂停
				clearInterval(timer);
				timer = null; //=>清除定时器后，记得把TIMER赋值为null
				handleTimer.value = "开始";
				return;
			}
			//=>TIMER不存在：创建新的定时器
			createTimer();
			handleTimer.value = "暂停";
		}


		//=>浏览器中的定时器有两种：设置一个定时器，规定在等待时间之后执行某个方法
		// setTimeout：执行一次
		// setInterval：一直会执行下去（每间隔这么长时间都会执行）
		//=>设置定时器会有一个返回值：是一个数字，代表当前是第几个定时器
		// clearTimeout(数字) / clearInterval(数字)：清除第几个定时器
		/* let n = 0,
			timer = null;
		timer = setInterval(() => {
			console.log(++n);
			if (n >= 5) {
				clearInterval(timer); //=>定时器清除了，但是此时的timer=1
				timer = null;
			}
		}, 1000); */
		// let timer2 = setInterval(() => {}, 1000);
		// let timer3 = setTimeout(() => {}, 1000);
		// console.log(timer, timer2, timer3);
	</script>
</body>
~~~

## 二十六.函数的防抖和节流

> http://underscore.org/     JS类库（提供很多项目中需要经常使用的方法）

### 函数的防抖（debounce）

> 函数的防抖（debounce）：不是某个事件触发就去执行函数，而是在指定的时间间隔内，执行一次，减少函数执行的次数

~~~js
/*
* debounce：函数防抖不是完成某个事件就去执行某函数，而是在某个间隔时间内只执行一次，避免函数的过多执行
*   @params
*      func:需要执行的函数
*      wait:设置的间隔时间
*      immediate:设置为ture时，调用触发于开始边界而不是结束边界
*   @return
*      返回可被调用的函数
* by Zero on 2019/08/20
*/
let debounce = function (func, wait, immediate) {
  //=>result用来存储函数执行返回的结果
  //=>timeout记录定时器
  let result = null,
      timeout = null;
  //=>返回可被执行的函数
  return function (...args) {
    //=>now记录的是事件触发的时候立即执行，还是需要等待间隔事件后执行
    let context = this,
        now = immediate && !timeout;
    //=>很重要：每一次设置新的定时器等待之前，都要先清空上一次设置的，确保间隔时间内只执行一次
    clearTimeout(timeout);
    //=>设置定时器：到达时间间隔后执行函数
    timeout = setTimeout(() => {
      timeout = null;
      if (!immediate) result = func.apply(context, args);
    }, wait);
    //=>如果是事件触发就执行，把函数执行即可
    if (now) result = func.apply(context, args);
    return result;
  };
};
~~~

### 函数的节流（throttle）

> 函数的节流（throttle）：为了缩减执行频率，但不像防抖一样，一定时间内只能执行一次，而是一定时间内能执行多次

~~~js
/*
* throttle：函数节流是为了缩减执行频率，当达到了一定的时间间隔就会执行一次
*   @params
*      func:需要执行的函数
*      wait:设置的间隔时间
*   @return
*      返回可被调用的函数
* by Zero on 2019/08/20
*/
let throttle = function (func, wait) {
  let timeout = null,
      result = null,
      previous = 0; //=>上次执行时间点
  return function (...args) {
    let now = new Date,
        context = this;
    //=>remaining小于等于0，表示上次执行至此所间隔时间已经超过一个时间间隔
    let remaining = wait - (now - previous);
    // console.log(remaining);
    if (remaining <= 0) {
      clearTimeout(timeout);
      previous = now;
      timeout = null;
      result = func.apply(context, args);
    } else if (!timeout) {
      timeout = setTimeout(() => {
        previous = new Date;
        timeout = null;
        result = func.apply(context, args);
      }, remaining);
    }
    return result;
  };
};
~~~

## 二十七.实战案例之瀑布流

**瀑布流效果及原理**

https://huaban.com/search/?q=Taylor+Swift

**瀑布流样式编写**

- 自己编写CSS
- 可基于Bootstrap组件实现

**瀑布流效果实现**

- 单例模式构建
- 基于JQUERY开发
- AJAX获取数据和数据绑定
- 图片懒加载
- 加载更多数据

**函数防抖与节流 （**[https://underscorejs.org](https://underscorejs.org/)**）**

- 两种常用的定时器基础语法
  - setTimeout
  - setInterval
  - clearTimeout / clearInterval
  - 定时器返回值

**HTML**

~~~html
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>花瓣网瀑布流效果</title>
	<!-- IMPORT CSS -->
	<link rel="stylesheet" href="css/reset.min.css">
	<link rel="stylesheet" href="css/index.css">
</head>

<body>
	<div class="container clearfix">
		<!-- column列 -->
		<div class="column">
			<!-- item每一项 -->
			<!-- <a class="item" href="">
				<div class="imgBox">
					<img src="img/1.jpg" alt="">
				</div>
				<p>泰勒·斯威夫特（Taylor Swift），1989年12月13日出生于美国宾州，美国歌手、演员。2006年出道，同年发行专辑《泰勒·斯威夫特》，该专辑获得美国唱片业协会的白金唱片认证</p>
			</a> -->
		</div>
		<div class="column"></div>
		<div class="column"></div>
	</div>

	<!-- IMPORT JS -->
	<script src="js/jquery-1.11.3.min.js"></script>
	<script src="node_modules/underscore/underscore.js"></script>
	<script src="js/index.js"></script>
</body>

</html>
~~~

**CSS**

~~~css
html,
body {
	background: #E4E4E4;
	overflow-x: hidden;
}

.container {
	box-sizing: border-box;
	margin: 20px auto;
	width: 1000px;
	/* display: flex; 基于FLEX实现水平排列，里面的每一项都会保持相同的高度，其中某一项变高，其余所有的项也都跟着变高 */
}

.container .column {
	box-sizing: border-box;
	float: left;
	margin-right: 20px;
	width: 320px;
}

.container .column:nth-last-child(1) {
	margin-right: 0;
}

.container .column .item {
	display: block;
	padding: 10px;
	margin-bottom: 10px;
	background: #FFF;
	box-shadow: 3px 3px 10px #666;
}

.container .column .item .imgBox {
	/* height: 300px; 想要实现图片延迟加载，这块显示默认占位图，事先需要知道图片的高度（从服务获取的数据中有图片高度） */
	background: url("../img/default.gif") no-repeat center center #EEE;
	overflow: hidden;
}

.container .column .item .imgBox img {
	display: none;
	width: 100%;
}

.container .column .item p {
	margin-top: 10px;
	font-size: 12px;
	color: #555;
	line-height: 20px;
}
~~~

**JS**

~~~JS
/*
* throttle：函数节流是为了缩减执行频率，当达到了一定的时间间隔就会执行一次
*   @params
*      func:需要执行的函数
*      wait:设置的间隔时间
*   @return
*      返回可被调用的函数
* by Zero on 2019/08/20
*/
let throttle = function (func, wait) {
  let timeout = null,
      result = null,
      previous = 0; //=>上次执行时间点
  return function (...args) {
    let now = new Date,
        context = this;
    //=>remaining小于等于0，表示上次执行至此所间隔时间已经超过一个时间间隔
    let remaining = wait - (now - previous);
    // console.log(remaining);
    if (remaining <= 0) {
      clearTimeout(timeout);
      previous = now;
      timeout = null;
      result = func.apply(context, args);
    } else if (!timeout) {
      timeout = setTimeout(() => {
        previous = new Date;
        timeout = null;
        result = func.apply(context, args);
      }, remaining);
    }
    return result;
  };
};



let flowModule = (function () {
	let $columns = $('.column'),
		_DATA = null;

	//=>queryData:基于AJAX从服务器获取数据
	let queryData = function () {
		$.ajax({
			url: 'json/data.json',
			method: 'GET',
			async: false,
			success: result => {
				_DATA = result;
			}
		});
	};

	//=>bindHTML:实现页面中的数据绑定
	let bindHTML = function () {
		//=>瀑布流实现的原理:每一次从_DATA中取出三条数据,按照三列由矮到高的顺序依次插入
		for (let i = 0; i < _DATA.length; i += 3) {
			//=>把数据按照图片由高到低排序
			let group = _DATA.slice(i, i + 3);
			if (i !== 0) {
				group.sort((A, B) => B.height - A.height);
			}

			//=>先按照高度排序（升序）
			$columns.sort((A, B) => {
				//=>A/B原生JS元素对象，想要使用JQ的方法，需要转换为JQ对象
				let $A = $(A),
					$B = $(B);
				return $A.outerHeight() - $B.outerHeight();
			}).each((index, column) => {
				//=>_DATA[i+index] 计算出要往每一列中插入的数据
				// let dataItem = _DATA[i + index];
				let dataItem = group[index];
				//=>没有数据，说明数据都已经处理完了，我们结束循环
				if (!dataItem) return false;
				let {
					pic,
					height,
					title,
					link
				} = dataItem;
				$(column).append(`<a class="item" href="${link}">
					<div class="imgBox" style="height:${height}px">
						<img src="" alt="" data-img="${pic}">
					</div>
					<p>${title}</p>
				</a>`);
			});
		}

		//=>实现图片延迟加载：数据绑定完，延迟1000MS加载真实的图片
		setTimeout(lazyImgs, 1000);
	};

	//=>lazyImgs:图片延迟加载
	let lazyImgs = function () {
		let $imgBoxs = $('.container .imgBox[isLoad!="true"]'),
			$window = $(window),
			B = $window.outerHeight() + $window.scrollTop();
		//=>循环每一个图片(图片盒子)，计算其底边距离BODY的偏移，从而验证出是否加载真实图片
		$imgBoxs.each((index, imgBox) => {
			let $imgBox = $(imgBox),
				$img = $imgBox.children('img'),
				A = $imgBox.outerHeight() + $imgBox.offset().top;
			// if ($imgBox.attr('isLoad') === "true") return;
			if (A <= B) {
				//=>加载真实图片
				$imgBox.attr('isLoad', 'true');
				$img.attr('src', $img.attr('data-img'));
				$img.on('load', () => {
					// $img.css('display', 'block');  //=>直接显示 
					$img.stop().fadeIn(); //=>基于JQ动画渐现显示
				});
			}
		});
	};

	//=>loadMore:加载更多数据
	let loadMore = function () {
		//=>滚动到底端（一屏幕高度+卷去的高度+500>=页面真实的高度），加载更多数据
		let $window = $(window),
			winH = $window.outerHeight(),
			scrollT = $window.scrollTop(),
			pageH = $(document).height();
		if (winH + scrollT + 500 >= pageH) {
			queryData();
			bindHTML();
		}
	};

	return {
		init: function () {
			queryData();
			bindHTML();

			//=>滚动条滚动处理一些事情
			window.onscroll = throttle(function () {
				//=>延迟加载图片
				lazyImgs();
				//=>加载更多数据
				loadMore();
			}, 50);
		}
	}
})();
flowModule.init();
~~~



## 二十八.动画的处理

- CSS3中的动画

  - transform中的2D变形

  - transition过渡动画
  - animation帧动画

- JS中的定时器动画

  - 限定步长

  - 限定时间
  - 简易封装动画库

- JQ中的动画方法

  - stop / finish

  - fadeIn / fadeOut / fadeToggle
  - show / hide / toggle
  - slideDown / slideUp / slideToggle
  - animate

- 扩展：requestAnimationFrame



### CSS3中的变形和动画

~~~html
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>CSS3中的变形和动画</title>
	<!-- IMPORT CSS -->
	<link rel="stylesheet" href="css/reset.min.css">
	<link rel="stylesheet" href="node_modules/animate.css/animate.min.css">
	<link rel="stylesheet" href="css/1-CSS3动画.css">
</head>

<body>
	<!-- <img src="images/1.jpg" alt="" class="meimei animated heartBeat"> -->
	<!-- <div class="box">珠峰培训</div> -->

	<img src="images/1.jpg" alt="" class="meimei">
</body>

</html>
~~~

~~~css
/*
 * CSS3中的变形属性：transform，改变元素的样式
 * 	 优势：开启了硬件加速，比传统的样式改变性能流畅一些
 *   特点：基于TRANSFORM变形的元素，相当于脱离了文档流，对其余元素的位置不会产生影响
 *   + scale(N) 缩放
 *   + translate(X,Y) 位移   translate3d(X,Y,Z)/translateX/translateY/translateZ
 *   + rotate(Ndeg) 旋转N度  rotateX/rotateY
 *   + skew(Ndeg) 倾斜N度    
 *   + matrix 矩阵变形       matrix3d
 */
.meimei {
	display: block;
	width: 400px;
	height: 300px;
	/* transform: scale(0.8) rotate(180deg) skew(-45deg); */
	/* transform: translate(200px,200px); */
}

/* .box {
	margin: 10px;
	width: 400px;
	height: 300px;
	background: lightblue;
} */

/*
 * CSS3中的过渡动画:transition
 *   给元素设置过渡效果，当元素的样式在某种情况下发生改变了，不是立即改变，而是按照指定的效果慢慢的去改变，从而实现动画效果
 *   + transition-property：设置过渡的样式属性（哪些样式改变会执行过渡效果），默认是all，元素所有的样式改变都会执行过渡效果
 *   + transition-druation：动画运行的时间 ms/s
 *   + transition-timing-function：运行的方式，linear默认值“匀速运动”、ease、ease-in、ease-out、ease-in-out、cubic-bezier...
 *   + transition-delay：设置延迟时间，默认值0s“立即执行”
 */
/* .meimei {
	/!* transition: all 1s linear 0s; *!/
	transition: .2s;
} */

/*.meimei:hover {
	transform: scale(1.5);
	-webkit-filter: grayscale(1);
} */

/*
 * CSS3中的帧动画：animation
 *   1.制作运动的轨迹（每一帧元素的样式） @keyframes
 *     @keyframes 动画名{
 *	       0%或者from{ 第一帧的样式 }
 *         ...
 *         50%{ 中间某帧的样式 }
 *         ...
 *         100%或者to{ 最后一帧的样式 }
 *     }
 *   2.播放动画（按照轨迹运动） animation
 *     + animation-name：动画名
 *     + animation-duration：播放的时间
 *     + animation-timing-function：运动方式，默认ease
 *     + animation-delay：延迟时间，默认0s
 *     + animation-iteration-count：播放次数，默认1，infinite无限次播放
 *     + animation-fill-mode：控制运动状态
 *         + forwards：animation动画，元素运动完，默认会返回第一帧所在的位置，如果设置了这个属性，则运动完停留在最后一帧的位置
 *         + backwards：在动画设置延迟时间的情况下，我们让元素在第一帧位置等待运行
 *         + both：同时具备以上两个特点
 */
/* @keyframes AAA {

	0%,
	100% {
		transform: translate(0, 0);
	}

	25% {
		transform: translate(800px, 0);
	}

	50% {
		transform: translate(800px, 400px);
	}

	75% {
		transform: translate(0, 400px);
	}
}

.meimei {
	animation: AAA 5s linear infinite both;
} */

@keyframes heartBeat {
	0% {
		transform: scale(1);
	}

	14% {
		transform: scale(1.3);
	}

	28% {
		transform: scale(1);
	}

	42% {
		transform: scale(1.3);
	}

	70% {
		transform: scale(1);
	}
}

.meimei {
	animation-name: heartBeat;
	animation-duration: 1.3s;
	animation-timing-function: ease-in-out;
}
~~~

### JS中的定时器动画

#### JS中的定时器

~~~html
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>JS中的定时器</title>
</head>

<body>
	<script>
		/*
		 * setTimeout
		 * setInterval 
		 * 定时器的返回值是一个数字，代表当前是第几个定时器
		 *   + 我们后期可以基于clearTimeout/clearInterval清除定时器
		 *   + 手动把timer赋值为null，后期基于它的值验证是否存在定时器
		 * 
		 * 定时器是异步编程的
		 */
		/* let timer = null;
		timer = setTimeout(() => {
			clearTimeout(timer);
			timer = null;
		}, 1000); */

		/* let n = 0;
		setTimeout(() => {
			n++;
			console.log(n); //=>2. 3
		}, 1000);
		n += 2;
		console.log(n); //=>1. 2 */

		/* let n = 0;
		setTimeout(() => {
			n++;
			console.log(n); //=>3
		}, 0); //=>写零也不是立即执行，而是有一个最小的等待时间，10MS左右
		n += 2;
		console.log(n); //=>2 */

		//=>定时器设置一个等待时间，到达时间后不一定执行（如果当前主线程被占用着，所有任务都要等主线程空闲下来，才能被安排执行 =>"因为JS是单线程的"）
		/* let n = 0;
		setTimeout(() => {
			n++;
			console.log(n); //=>3
		}, 0);
		console.time('AA');
		for (let i = 0; i < 90000000; i++) {}
		console.timeEnd('AA');
		n += 2;
		console.log(n);//=>2  */

		/* let n = 0;
		setTimeout(() => {
			n++;
			console.log(n); //=>没有执行，主线程被死循环给牵绊住了
		}, 0);
		n += 2;
		console.log(n); //=>2
		while (1 === 1) {

		} */


		/* let n = 0;
		setTimeout(() => {
			n++;
			console.log(n); //=>4. 6
		}, 500);
		setTimeout(() => {
			n += 2;
			console.log(n); //=>2. 2
		}, 50);
		//=>约等于160ms
		for (let i = 0; i < 90000000; i++) {}
		setTimeout(() => {
			n += 3;
			console.log(n); //=>3. 5
		}, 20);
		console.log(n);//=>1. 0 */

		/* let n = 0;
		setTimeout(() => {
			n++;
			console.log(n);
		}, 500);
		setTimeout(() => {
			n += 2;
			console.log(n); //=>2
			while (1 === 1) {}
		}, 50);
		for (let i = 0; i < 90000000; i++) {}
		console.log(n); //=>0 */
	</script>
</body>

</html>
~~~

#### 浏览器渲染原理

![浏览器渲染原理](C:\Users\左海之浅\Desktop\课程笔记\图片文件\浏览器渲染原理.png)

#### 浏览器渲染原理-JS异步编程

![浏览器渲染原理-JS异步编程](C:\Users\左海之浅\Desktop\课程笔记\图片文件\浏览器渲染原理-JS异步编程.png)

![JS异步编程](C:\Users\左海之浅\Desktop\课程笔记\图片文件\JS异步编程.png)

#### 定时器动画

~~~html
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>定时器动画</title>
	<!-- IMPORT CSS -->
	<link rel="stylesheet" href="css/reset.min.css">
	<style>
		.nezha {
			position: absolute;
			top: 0;
			left: 0px;
			width: 100px;
			border: 1px solid lightcoral;
			/* 设置过渡动画 */
			/* transition: 1s linear; */
		}
	</style>
</head>

<body>
	<img src="images/nz1.jpg" alt="" class="nezha">

	<!-- IMPORT JS -->
	<script src="jquery-1.11.3.min.js"></script>
	<!-- JQ -->
	<script>
		/*
		 * animate:JQ中实现的动画库 
		 *   $元素.animate(目标样式,运动时间,运动方式,运动完执行的函数)
		 * stop:结束当前正在运行的动画,从现有的位置开始继续新的动画
		 * finish:也是结束当前正在运行的动画,和STOP的区别是,FINSH是结束后快速运动到动画的结束位置，在开启新的动画
		 * 
		 * 快捷动画
		 *   show/hide/toggle  显示/隐藏/显示隐藏的切换
		 *   fadeIn/fadeOut/fadeToggle  渐隐渐现
		 *   slideDown/slideUp/slideToggle 下拉和卷起
		 *   ...
		 */
		let $nezha = $('.nezha'),
			$window = $(window),
			targetL = $window.outerWidth() - $nezha.outerWidth(),
			targetT = $window.outerHeight() - $nezha.outerHeight();
		$nezha.click(function () {
			// $nezha.hide(1000); //=>"slow" / "fast" / 具体时间
			// $nezha.fadeOut(1000);
			// $nezha.slideUp(1000);
		});

		/* $nezha.stop().animate({
			top: targetT,
			left: targetL
		}, 2000, 'linear', () => {
			$nezha.css('transform', 'rotate(180deg)');
		}); */
	</script>

	<!-- 多方向，规定时间，匀速动画 -->
	<script>
		/* let nezha = document.querySelector('.nezha'),
			targetL = document.documentElement.clientWidth - nezha.offsetWidth,
			targetT = document.documentElement.clientHeight - nezha.offsetHeight; */

		/* 
		 * animate:封装一个简易的动画库
		 *   @params
		 *      curEle:当前要运动的元素
		 *      target:目标样式值  对象:{left:xxx,top:xxx}
		 *      duration:总时间
		 *      callback:回调函数，动画完成后做什么事
		 */
		/* function animate(curEle, target = {}, duration = 1000, callback) {
			//=>准备T/B/C/D
			let time = 0,
				begin = {},
				change = {};
			for (let key in target) {
				begin[key] = parseFloat(getComputedStyle(curEle)[key]);
				change[key] = target[key] - begin[key];
			}
			//=>设置定时器开始运动
			let timer = setInterval(() => {
				time += 16.7;
				//=>边界
				if (time >= duration) {
					clearInterval(timer);
					timer = null;
					for (let key in target) {
						curEle['style'][key] = target[key] + 'px';
					}
					//=>运动完执行回调函数
					// callback && callback();
					typeof callback === "function" ? callback() : null;
					return;
				}
				//=>获取当前方向的样式值
				for (let key in target) {
					let cur = time / duration * change[key] + begin[key];
					curEle['style'][key] = cur + 'px';
				}
			}, 16.7);
		}
		
		animate(nezha, {
			left: targetL,
			top: targetT
		}, 2000, () => {
			nezha.style.transform = "rotate(180deg)";
		}); */

		/* let time = 0,
			duration = 1000,
			beginL = 0,
			beginT = 0,
			changeL = targetL - beginL,
			changeT = targetT - beginT;
		let timer = setInterval(() => {
			time += 16.7;
			if (time >= duration) {
				nezha.style.left = targetL + 'px';
				nezha.style.top = targetT + 'px';
				clearInterval(timer);
				timer = null;
				return;
			}
			let curL = time / duration * changeL + beginL,
				curT = time / duration * changeT + beginT;
			nezha.style.left = curL + 'px';
			nezha.style.top = curT + 'px';
		}, 16.7); */
	</script>


	<!-- CSS3动画 -->
	<script>
		/* let nezha = document.querySelector('.nezha'),
			targetL = document.documentElement.clientWidth - nezha.offsetWidth,
			targetT = document.documentElement.clientHeight - nezha.offsetHeight;
		nezha.style.transform = `translate(${targetL}px,${targetT}px)`; */
	</script>

	<!-- 定时器动画 -->
	<script>
		/* 定时器动画：限定步长 */
		/* let nezha = document.querySelector('.nezha'),
			//=>target:目标样式
			target = document.documentElement.clientWidth - nezha.offsetWidth,
			//=>step:步长
			step = 10;
		//=>设置定时器，让其每间隔17MS走一步（改变LEFT/TRANSFORM:TRANSLATEX）
		let timer = setInterval(() => {
			//1.获取当前盒子的位置，在现有的位置上加STEP
			let curL = parseFloat(window.getComputedStyle(nezha).left);
			if ((curL + step) >= target) {
				//=>到达边界（边界判断是在当前位置的基础上加上步长去验证的）
				nezha.style.left = target + 'px';
				clearInterval(timer);
				timer = null;
				return;
			}
			//2.重新给元素设置样式
			curL += step;
			nezha.style.left = curL + 'px';
		}, 17); */
	</script>
	<script>
		/* 
		 * 定时器动画：限定时间的匀速运动 
		 *    T:TIME 当前已经运动的时间
		 *    B:BEGIN 开始位置
		 *    D:DURATION 总时间
		 *    C:CHANGE 总距离
		 * 当前位置 = T/D*C+B
		 */
		/* let nezha = document.querySelector('.nezha'),
			//=>TARGET 目标位置
			target = document.documentElement.clientWidth - nezha.offsetWidth,
			//=>BEGIN 起始位置
			begin = parseFloat(window.getComputedStyle(nezha).left),
			//=>CHANGE 总距离
			change = target - begin,
			//=>DURATION 总时间
			duration = 1000,
			//=>TIME 已经运动的时间
			time = 0;
		let timer = setInterval(() => {
			time += 17;
			if (time >= duration) {
				nezha.style.left = target + 'px';
				clearInterval(timer);
				timer = null;
				return;
			}
			let curL = time / duration * change + begin;
			// let curL = effect(time, begin, change, duration);
			nezha.style.left = curL + 'px';
		}, 17);

		function effect(t, b, c, d) { 
			if ((t /= d) < (1 / 2.75)) {
				return c * (7.5625 * t * t) + b;
			} else if (t < (2 / 2.75)) {
				return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
			} else if (t < (2.5 / 2.75)) {
				return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
			} else {
				return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
			}
		}
		*/
	</script>

	<!-- requestAnimationFram -->
	<script>
		// https://blog.csdn.net/vhwfr2u02q/article/details/79492303
		/* function effect(t, b, c, d) { 
			if ((t /= d) < (1 / 2.75)) {
				return c * (7.5625 * t * t) + b;
			} else if (t < (2 / 2.75)) {
				return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
			} else if (t < (2.5 / 2.75)) {
				return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
			} else {
				return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
			}
		}*/

		/* window.requestAnimationFrame：JS中比定时器动画更好的方式（HTML5中提供的）*/
		/* let nezha = document.querySelector('.nezha'),
			target = document.documentElement.clientWidth - nezha.offsetWidth,
			begin = parseFloat(window.getComputedStyle(nezha).left),
			change = target - begin,
			duration = 1000,
			time = 0;
		function render() {
			time += 16.7;
			if (time >= duration) {
				nezha.style.left = target + 'px';
				return;
			}
			let curL = effect(time, begin, change, duration);
			nezha.style.left = curL + 'px';
			window.requestAnimationFrame(render);
		}
		window.requestAnimationFrame(render); */
	</script>
</body>

</html>
~~~

#### 动画运动公式

~~~js
var animationEffect = {
	Linear: function (t, b, c, d) {
		return c * t / d + b;
	},
	Bounce: {
		easeIn: function (t, b, c, d) {
			return c - animationEffect.Bounce.easeOut(d - t, 0, c, d) + b;
		},
		easeOut: function (t, b, c, d) {
			if ((t /= d) < (1 / 2.75)) {
				return c * (7.5625 * t * t) + b;
			} else if (t < (2 / 2.75)) {
				return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
			} else if (t < (2.5 / 2.75)) {
				return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
			} else {
				return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
			}
		},
		easeInOut: function (t, b, c, d) {
			if (t < d / 2) {
				return animationEffect.Bounce.easeIn(t * 2, 0, c, d) * .5 + b;
			}
			return animationEffect.Bounce.easeOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
		}
	},
	Quad: {
		easeIn: function (t, b, c, d) {
			return c * (t /= d) * t + b;
		},
		easeOut: function (t, b, c, d) {
			return -c * (t /= d) * (t - 2) + b;
		},
		easeInOut: function (t, b, c, d) {
			if ((t /= d / 2) < 1) {
				return c / 2 * t * t + b;
			}
			return -c / 2 * ((--t) * (t - 2) - 1) + b;
		}
	},
	Cubic: {
		easeIn: function (t, b, c, d) {
			return c * (t /= d) * t * t + b;
		},
		easeOut: function (t, b, c, d) {
			return c * ((t = t / d - 1) * t * t + 1) + b;
		},
		easeInOut: function (t, b, c, d) {
			if ((t /= d / 2) < 1) {
				return c / 2 * t * t * t + b;
			}
			return c / 2 * ((t -= 2) * t * t + 2) + b;
		}
	},
	Quart: {
		easeIn: function (t, b, c, d) {
			return c * (t /= d) * t * t * t + b;
		},
		easeOut: function (t, b, c, d) {
			return -c * ((t = t / d - 1) * t * t * t - 1) + b;
		},
		easeInOut: function (t, b, c, d) {
			if ((t /= d / 2) < 1) {
				return c / 2 * t * t * t * t + b;
			}
			return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
		}
	},
	Quint: {
		easeIn: function (t, b, c, d) {
			return c * (t /= d) * t * t * t * t + b;
		},
		easeOut: function (t, b, c, d) {
			return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
		},
		easeInOut: function (t, b, c, d) {
			if ((t /= d / 2) < 1) {
				return c / 2 * t * t * t * t * t + b;
			}
			return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
		}
	},
	Sine: {
		easeIn: function (t, b, c, d) {
			return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
		},
		easeOut: function (t, b, c, d) {
			return c * Math.sin(t / d * (Math.PI / 2)) + b;
		},
		easeInOut: function (t, b, c, d) {
			return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
		}
	},
	Expo: {
		easeIn: function (t, b, c, d) {
			return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
		},
		easeOut: function (t, b, c, d) {
			return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
		},
		easeInOut: function (t, b, c, d) {
			if (t == 0) return b;
			if (t == d) return b + c;
			if ((t /= d / 2) < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
			return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
		}
	},
	Circ: {
		easeIn: function (t, b, c, d) {
			return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
		},
		easeOut: function (t, b, c, d) {
			return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
		},
		easeInOut: function (t, b, c, d) {
			if ((t /= d / 2) < 1) {
				return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
			}
			return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
		}
	},
	Back: {
		easeIn: function (t, b, c, d, s) {
			if (s == undefined) s = 1.70158;
			return c * (t /= d) * t * ((s + 1) * t - s) + b;
		},
		easeOut: function (t, b, c, d, s) {
			if (s == undefined) s = 1.70158;
			return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
		},
		easeInOut: function (t, b, c, d, s) {
			if (s == undefined) s = 1.70158;
			if ((t /= d / 2) < 1) {
				return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
			}
			return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
		}
	},
	Elastic: {
		easeIn: function (t, b, c, d, a, p) {
			if (t == 0) return b;
			if ((t /= d) == 1) return b + c;
			if (!p) p = d * .3;
			var s;
			!a || a < Math.abs(c) ? (a = c, s = p / 4) : s = p / (2 * Math.PI) * Math.asin(c / a);
			return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
		},
		easeOut: function (t, b, c, d, a, p) {
			if (t == 0) return b;
			if ((t /= d) == 1) return b + c;
			if (!p) p = d * .3;
			var s;
			!a || a < Math.abs(c) ? (a = c, s = p / 4) : s = p / (2 * Math.PI) * Math.asin(c / a);
			return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b);
		},
		easeInOut: function (t, b, c, d, a, p) {
			if (t == 0) return b;
			if ((t /= d / 2) == 2) return b + c;
			if (!p) p = d * (.3 * 1.5);
			var s;
			!a || a < Math.abs(c) ? (a = c, s = p / 4) : s = p / (2 * Math.PI) * Math.asin(c / a);
			if (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
			return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * .5 + c + b;
		}
	}
};
~~~



## 二十九.实战案例：轮播图

- 基于JQUERY的animate方法实现
  - 左右切换版

- 基于JQUERY和CSS3动画结合实现
  - 渐隐渐现版   

- 基于SWIPER插件实现
- 封装成为JQUERY插件

### 基于jQuery的animate方法实现左右运动

#### 左右运动的轮播图原理图解

![左右运动的轮播图](C:\Users\左海之浅\Desktop\课程笔记\图片文件\左右运动的轮播图.png)

#### HTML+CSS

~~~html
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>轮播图左右运动版</title>
	<!-- IMPORT CSS -->
	<link rel="stylesheet" href="css/reset.min.css">
	<style>
		.container {
			position: relative;
			box-sizing: border-box;
			margin: 0 auto;
			width: 1200px;
			height: 240px;
			overflow: hidden;
		}

		.container .wrapper {
			position: absolute;
			top: 0;
			left: 0;
			box-sizing: border-box;
			width: 6000px;
			height: 100%;
			display: flex;
		}

		.container .wrapper .slider {
			box-sizing: border-box;
			width: 1200px;
			height: 100%;
		}

		.container .wrapper .slider img {
			width: 100%;
			height: 100%;
		}

		/* 分页器 */
		.pagenition {
			position: absolute;
			z-index: 999;
			bottom: 10px;
			left: 50%;
			transform: translateX(-50%);
			padding: 5px 10px;
			background: rgba(255, 255, 255, .3);
			font-size: 0;
			border-radius: 26px;
		}

		.pagenition li {
			display: inline-block;
			margin: 0 10px;
			width: 16px;
			height: 16px;
			border-radius: 50%;
			background: lightblue;
			cursor: pointer;
		}

		.pagenition li.active {
			background: lightcoral;
		}

		/* 左右按钮 */
		.arrow {
			display: none;
			position: absolute;
			z-index: 999;
			top: 50%;
			margin-top: -22.5px;
			width: 30px;
			height: 45px;
			background: url(images/pre.png) no-repeat 0 0;
		}

		.arrow.changeLeft {
			left: 0;
		}

		.arrow.changeRight {
			right: 0;
			background-position: -50px 0;
		}

		.container:hover .arrow {
			display: block;
		}
	</style>
</head>

<body>
	<!-- 轮播图容器 -->
	<div class="container">
		<!-- WRAPPER存放所有的图 -->
		<div class="wrapper">
			<!-- SLIDER每一个轮播图 -->
			<div class="slider">
				<img src="images/banner01.png" alt="">
			</div>
			<div class="slider">
				<img src="images/banner02.png" alt="">
			</div>
			<div class="slider">
				<img src="images/banner03.jpg" alt="">
			</div>
			<div class="slider">
				<img src="images/banner04.png" alt="">
			</div>
			<!-- 克隆的那份（无缝衔接） -->
			<div class="slider">
				<img src="images/banner01.png" alt="">
			</div>
		</div>

		<!-- PAGENATION分页器 -->
		<ul class="pagenition">
			<li class="active"></li>
			<li></li>
			<li></li>
			<li></li>
		</ul>

		<!-- 左右按钮 -->
		<a href="javascript:;" class="arrow changeLeft"></a>
		<a href="javascript:;" class="arrow changeRight"></a>
	</div>

	<!-- IMPORT JS -->
	<script src="js/jquery.min.js"></script>
	<script src="js/banner.js"></script>
</body>

</html>
~~~

#### JS

~~~JS
function debounce(func, wait, immediate) {
	let timer = null,
		result = null;
	return function anonymous(...args) {
		let context = this,
			now = immediate && !timer;
		clearTimeout(timer);
		timer = setTimeout(() => {
			timer = null;
			!immediate ? result = func.call(context, ...args) : null;
		}, wait);
		now ? result = func.call(context, ...args) : null;
		return result;
	}
}

let bannerModule = (function () {
	let $container = $('.container'),
		$wrapper = $container.find('.wrapper'),
		$changeLeft = $container.find('.changeLeft'),
		$changeRight = $container.find('.changeRight'),
		$pagenition = $container.find('.pagenition'),
		$pagenitionList = $pagenition.find('li');
	let step = 0,
		autoTimer = null,
		interval = 1000;

	//=>自动轮播
	function autoMove() {
		step++;
		if (step >= 5) {
			$wrapper.css('left', 0);
			step = 1;
		}
		$wrapper.stop().animate({
			left: -step * 1200
		}, 300);
		//=>自动焦点对齐
		autoFocus();
	}

	//=>自动对焦
	function autoFocus() {
		let temp = step;
		temp === 4 ? temp = 0 : null;
		$pagenitionList.each((index, item) => {
			let $item = $(item);
			if (index === temp) {
				$item.addClass('active');
				return;
			}
			$item.removeClass('active');
		});
	}

	//=>点击焦点切换到指定的位置
	function handlePagenition() {
		$pagenitionList.click(debounce(function () {
			let index = $(this).index();
			step = index;
			$wrapper.stop().animate({
				left: -step * 1200
			}, 300);
			autoFocus();
		}, 300, true));
	}

	//=>点击按钮处理
	function handleArrow() {
		//=>右按钮处理（和自动一样）
		$changeRight.click(debounce(autoMove, 300, true));

		//=>左按钮处理
		$changeLeft.click(debounce(function () {
			step--;
			if (step < 0) {
				$wrapper.css('left', -4 * 1200);
				step = 3;
			}
			$wrapper.stop().animate({
				left: -step * 1200
			}, 300);
			autoFocus();
		}, 300, true));
	}

	return {
		init() {
			autoTimer = setInterval(autoMove, interval);
			//=>控制自动轮播的暂停和开始
			$container.on('mouseenter', () => clearInterval(autoTimer))
				.on('mouseleave', () => autoTimer = setInterval(autoMove, interval));
			//=>焦点点击
			handlePagenition();
			//=>按钮点击
			handleArrow();
		}
	}
})();
bannerModule.init();




/* let $container = $('.container'),
	$wrapper = $container.children('.wrapper');

//=>timer：存储自动轮播的定时器  step：当前展示的是索引为N的SLIDER
let timer = null,
	step = 0;

//=>autoMove:开启自动轮播
function autoMove() {
	//=>让WRAPPER向左移动
	step++;
	if (step >= 5) {
		//=>上一次显示的克隆的第一张，此时我们让其“立即”跳转到真实的第一张(LEFT=0)，然后在让其运动到第二张即可
		$wrapper.css("left", 0);
		step = 1;
	}
	$wrapper.stop().animate({
		//=>JQ中的ANIMATE动画库,不支持CSS3中的TRANSFORM样式改变
		left: -step * 1200
	}, 300);
}
timer = setInterval(autoMove, 1000); */
~~~

### 基于SWIPER插件实现左右运动

#### HTML+CSS+JS

~~~HTML
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>轮播图左右运动版</title>
	<!-- IMPORT CSS -->
	<link rel="stylesheet" href="css/reset.min.css">
	<link rel="stylesheet" href="css/swiper.min.css">
	<style>
		.swiper-container,
		.swiper-slide,
		.swiper-slide img {
			width: 1200px;
			height: 240px;
		}
	</style>
</head>

<body>
	<div class="swiper-container">
		<div class="swiper-wrapper">
			<div class="swiper-slide">
				<img src="images/banner01.png" alt="">
			</div>
			<div class="swiper-slide">
				<img src="images/banner02.png" alt="">
			</div>
			<div class="swiper-slide">
				<img src="images/banner03.jpg" alt="">
			</div>
			<div class="swiper-slide">
				<img src="images/banner04.png" alt="">
			</div>
		</div>

		<!-- 分页器 -->
		<ul class="swiper-pagination"></ul>

		<!-- 左右按钮 -->
		<div class="swiper-button-prev"></div>
		<div class="swiper-button-next"></div>
	</div>

	<!-- IMPORT JS -->
	<!-- <script src="js/jquery.min.js"></script> -->
	<script src="js/swiper.min.js"></script>
	<script>
		new Swiper('.swiper-container', {
			loop: true,
			autoplay: {
				delay: 1000,
				disableOnInteraction: false
			},
			pagination: {
				el: '.swiper-pagination',
				type: 'bullets'
			},
			effect: "slide",
			navigation: {
				nextEl: '.swiper-button-next',
				prevEl: '.swiper-button-prev',
			}
		});
	</script>
</body>

</html>
~~~

### 渐隐渐现版轮播图开发

- 技术栈：JQUERY + CSS3中的TRANSITION动画 + 高级单例模式
- 效果的整体实现思路和基本结构样式  
- 完成轮播图内容的动态数据绑定（JQUERY中AJAX异步编程处理）
  - 同步异步
  - 回调函数的应用
- 自动轮播效果处理
- 焦点对齐和触发焦点实现轮播
- 左右按钮切换实现轮播
- 函数的防抖和节流处理

#### 渐隐渐现轮播图实现原理图

![渐隐渐现版轮播图](C:\Users\左海之浅\Desktop\课程笔记\图片文件\渐隐渐现版轮播图.png)

#### HTML

~~~HTML
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>珠峰培训-渐隐渐现版轮播图</title>
	<!-- IMPORT CSS -->
	<link rel="stylesheet" href="css/reset.min.css">
	<link rel="stylesheet" href="css/banner.css">
</head>

<body>
	<section class="container">
		<!-- 轮播图容器 -->
		<div class="wrapper">
			<!-- <div class="slide">
				<img src="images/banner01.png" alt="">
			</div> -->
		</div>
		<!-- 分页器容器 -->
		<div class="pagination">
			<!-- <span class="active"></span>
			<span></span> -->
		</div>
		<!-- 前进后退按钮 -->
		<a href="javascript:;" class="button-prev"></a>
		<a href="javascript:;" class="button-next"></a>
	</section>

	<!-- IMPORT JS -->
	<script src="js/jquery.min.js"></script>
	<script src="js/banner.js"></script>
</body>

</html>
~~~

#### CSS

~~~css
.container {
	box-sizing: border-box;
	position: relative;
	margin: 20px auto;
	width: 1226px;
	height: 460px;
	overflow: hidden;
}

.container .wrapper {
	position: relative;
	height: 100%;
}

.container .wrapper .slide {
	position: absolute;
	top: 0;
	left: 0;
	box-sizing: border-box;
	width: 100%;
	height: 100%;
	/* 所有SLIDE默认样式 */
	z-index: 0;
	opacity: 0;
}

.container .wrapper .slide:nth-child(1) {
	/* 默认第一个展示 */
	z-index: 1;
	opacity: 1;
}

.container .wrapper .slide img {
	width: 100%;
	height: 100%;
}

.container .pagination {
	position: absolute;
	right: 20px;
	bottom: 20px;
	z-index: 999;
	font-size: 0;
}

.container .pagination span {
	display: inline-block;
	margin: 0 4px;
	width: 6px;
	height: 6px;
	background: rgba(0, 0, 0, .4);
	border: 2px solid rgba(255, 255, 255, .4);
	border-radius: 50%;
	cursor: pointer;
}

.container .pagination span.active {
	background: rgba(255, 255, 255, .4);
	border-color: rgba(0, 0, 0, .4);
}

.container .button-prev,
.container .button-next {
	position: absolute;
	top: 50%;
	margin-top: -35px;
	z-index: 999;
	width: 40px;
	height: 70px;
	background: url("../images/icon-slides.png") no-repeat;
}

.container .button-prev {
	left: 0;
	background-position: -83px 0;
}

.container .button-prev:hover {
	background-position: 0 0;
}

.container .button-next {
	right: 0;
	background-position: -124px 0;
}

.container .button-next:hover {
	background-position: -41px 0;
}
~~~

#### JS

~~~js
function throttle(func, wait) {
	let timer = null,
		result = null,
		previous = 0;
	return function anonymous(...args) {
		let context = this,
			now = new Date,
			spanTime = wait - (now - previous);
		if (spanTime <= 0) {
			result = func.call(context, ...args);
			clearTimeout(timer);
			timer = null;
			previous = now;
		} else if (!timer) {
			timer = setTimeout(() => {
				result = func.call(context, ...args);
				timer = null;
				previous = new Date;
			}, spanTime);
		}
		return result;
	}
}

function debounce(func, wait, immediate) {
	let timer = null,
		result = null;
	return function anonymous(...args) {
		let context = this,
			now = immediate && !timer;
		clearTimeout(timer);
		timer = setTimeout(() => {
			timer = null;
			!immediate ? result = func.call(context, ...args) : null;
		}, wait);
		now ? result = func.call(context, ...args) : null;
		return result;
	}
}


let bannerModule = (function () {
	let $container = $('.container'),
		$wrapper = $container.find('.wrapper'),
		$pagination = $container.find('.pagination'),
		$buttonPrev = $container.find('.button-prev'),
		$buttonNext = $container.find('.button-next'),
		$slideList = null,
		$paginationList = null;

	let autoTimer = null,
		interval = 1000,
		speed = 300,
		activeIndex = 0,
		count = 0;

	//=>queryData：获取数据
	let queryData = function (callBack) {
		$.ajax({
			url: 'json/bannerData1.json',
			method: 'get',
			async: true,
			success: result => {
				// typeof callBack === 'function' ? callBack() : null;
				callBack && callBack(result);
			}
		});
	};

	//=>bindHTML：数据绑定
	let bindHTML = function (data) {
		let str1 = ``,
			str2 = ``;
		data.forEach((item, index) => {
			str1 += `<div class="slide">
				<img src="${item.pic}" alt="">
			</div>`;

			str2 += `<span class="${index===0?'active':''}"></span>`;
		});
		$wrapper.html(str1);
		$pagination.html(str2);

		//=>获取结构内容
		$slideList = $wrapper.children('.slide');
		$paginationList = $pagination.children('span');
	};

	//=>autoMove：自动轮播
	let change = function () {
		let $active = $slideList.eq(activeIndex),
			$siblings = $active.siblings();
		//基于CSS3中的TRANSITION实现动画
		$active.css('transition', `opacity ${speed}ms`);
		$siblings.css('transition', `opacity 0ms`);
		$active.css('z-index', 1);
		$siblings.css('z-index', 0);
		$active.css('opacity', 1).on('transitionend', function () {
			//=>transitionend：当CSS3过渡动画结束后触发的事件，特殊注意的是，如果是多个样式执行了过渡效果，则当前事件被触发多次
			$siblings.css('opacity', 0);
		});
		autoFocus();
	};
	let autoMove = function () {
		//1.每一次进来步长累加，累加到超过边界，则从头开始
		activeIndex++;
		activeIndex >= count ? activeIndex = 0 : null;
		//2.实现切换
		change();
	};

	//=>autoFocus：焦点对齐
	let autoFocus = function () {
		$paginationList.each((index, item) => {
			let $item = $(item);
			if (index === activeIndex) {
				$item.addClass('active');
				return;
			}
			$item.removeClass('active');
		});
	};

	//=>handlePagination：给焦点绑定触发的事件
	let handlePagination = function () {
		$paginationList.mouseover(throttle(function () {
			activeIndex = $(this).index();
			change();
		}, 500));
	};

	//=>handleButton：点击左右按钮实现切换
	let handleButton = function () {
		$buttonNext.click(throttle(autoMove, 300));
		$buttonPrev.click(throttle(function () {
			activeIndex--;
			activeIndex < 0 ? activeIndex = count - 1 : null;
			change();
		}, 500));
	};

	return {
		init() {
			//=>AJAX采用异步编程，我们需要在获取到数据后，才能进行数据绑定，轮播图处理等事情，此时我们可以基于回调函数来完成这件事情
			queryData(function anonymous(data) {
				//=>DATA就是从服务器获取的数据
				bindHTML(data);
				count = data.length;
				autoTimer = setInterval(autoMove, interval);
				handlePagination();
				handleButton();
			});

			$container.mouseenter(function () {
				clearInterval(autoTimer);
			}).mouseleave(function () {
				autoTimer = setInterval(autoMove, interval);
			});
		}
	}
})();
bannerModule.init();
~~~

### 事件委托版-渐隐渐现轮播图

#### HTML

~~~javascript
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>珠峰培训-渐隐渐现版轮播图</title>
	<!-- IMPORT CSS -->
	<link rel="stylesheet" href="css/reset.min.css">
	<link rel="stylesheet" href="css/banner.css">
</head>

<body>
	<section class="container">
		<!-- 轮播图容器 -->
		<div class="wrapper">
			<!-- <div class="slide">
				<img src="images/banner01.png" alt="">
			</div> -->
		</div>
		<!-- 分页器容器 -->
		<div class="pagination">
			<!-- <span class="active"></span>
			<span></span> -->
		</div>
		<!-- 前进后退按钮 -->
		<a href="javascript:;" class="button-prev"></a>
		<a href="javascript:;" class="button-next"></a>
	</section>

	<!-- IMPORT JS -->
	<script src="js/jquery.min.js"></script>
	<script src="js/banner.js"></script>
</body>

</html>
~~~

#### CSS

~~~javascript
.container {
	box-sizing: border-box;
	position: relative;
	margin: 20px auto;
	width: 1226px;
	height: 460px;
	overflow: hidden;
}

.container .wrapper {
	position: relative;
	height: 100%;
}

.container .wrapper .slide {
	position: absolute;
	top: 0;
	left: 0;
	box-sizing: border-box;
	width: 100%;
	height: 100%;
	/* 所有SLIDE默认样式 */
	z-index: 0;
	opacity: 0;
}

.container .wrapper .slide:nth-child(1) {
	/* 默认第一个展示 */
	z-index: 1;
	opacity: 1;
}

.container .wrapper .slide img {
	width: 100%;
	height: 100%;
}

.container .pagination {
	position: absolute;
	right: 20px;
	bottom: 20px;
	z-index: 999;
	font-size: 0;
}

.container .pagination span {
	display: inline-block;
	margin: 0 4px;
	width: 6px;
	height: 6px;
	background: rgba(0, 0, 0, .4);
	border: 2px solid rgba(255, 255, 255, .4);
	border-radius: 50%;
	cursor: pointer;
}

.container .pagination span.active {
	background: rgba(255, 255, 255, .4);
	border-color: rgba(0, 0, 0, .4);
}

.container .button-prev,
.container .button-next {
	position: absolute;
	top: 50%;
	margin-top: -35px;
	z-index: 999;
	width: 40px;
	height: 70px;
	background: url("../images/icon-slides.png") no-repeat;
}

.container .button-prev {
	left: 0;
	background-position: -83px 0;
}

.container .button-prev:hover {
	background-position: 0 0;
}

.container .button-next {
	right: 0;
	background-position: -124px 0;
}

.container .button-next:hover {
	background-position: -41px 0;
}
~~~

#### JS

~~~javascript
function throttle(func, wait) {
	let timer = null,
		result = null,
		previous = 0;
	return function anonymous(...args) {
		let context = this,
			now = new Date,
			spanTime = wait - (now - previous);
		if (spanTime <= 0) {
			result = func.call(context, ...args);
			clearTimeout(timer);
			timer = null;
			previous = now;
		} else if (!timer) {
			timer = setTimeout(() => {
				result = func.call(context, ...args);
				timer = null;
				previous = new Date;
			}, spanTime);
		}
		return result;
	}
}

function debounce(func, wait, immediate) {
	let timer = null,
		result = null;
	return function anonymous(...args) {
		let context = this,
			now = immediate && !timer;
		clearTimeout(timer);
		timer = setTimeout(() => {
			timer = null;
			!immediate ? result = func.call(context, ...args) : null;
		}, wait);
		now ? result = func.call(context, ...args) : null;
		return result;
	}
}

let bannerModule = (function () {
	let $container = $('.container'),
		$wrapper = $container.find('.wrapper'),
		$pagination = $container.find('.pagination'),
		$slideList = null;

	let autoTimer = null,
		interval = 1000,
		speed = 300,
		activeIndex = 0,
		count = 0;

	//=>queryData：获取数据
	let queryData = function (callBack) {
		$.ajax({
			url: 'json/bannerData1.json',
			method: 'get',
			async: true,
			success: result => {
				callBack && callBack(result);
			}
		});
	};

	//=>bindHTML：数据绑定
	let bindHTML = function (data) {
		let str1 = ``,
			str2 = ``;
		data.forEach((item, index) => {
			str1 += `<div class="slide">
				<img src="${item.pic}" alt="">
			</div>`;

			str2 += `<span class="${index===0?'active':''}"></span>`;
		});
		$wrapper.html(str1);
		$pagination.html(str2);
		//=>获取结构内容
		$slideList = $wrapper.children('.slide');
	};

	//=>autoMove：自动轮播
	let change = function () {
		let $active = $slideList.eq(activeIndex),
			$siblings = $active.siblings();
		$active.css('transition', `opacity ${speed}ms`);
		$siblings.css('transition', `opacity 0ms`);
		$active.css('z-index', 1);
		$siblings.css('z-index', 0);
		$active.css('opacity', 1).on('transitionend', function () {
			$siblings.css('opacity', 0);
		});

		$pagination.children('span').each((index, item) => {
			let $item = $(item);
			if (index === activeIndex) {
				$item.addClass('active');
				return;
			}
			$item.removeClass('active');
		});
	};
	let autoMove = function () {
		activeIndex++;
		activeIndex >= count ? activeIndex = 0 : null;
		change();
	};

	return {
		init() {
			queryData(function anonymous(data) {
				bindHTML(data);
				count = data.length;
				autoTimer = setInterval(autoMove, interval);
			});
			$container.mouseenter(function () {
				clearInterval(autoTimer);
			}).mouseleave(function () {
				autoTimer = setInterval(autoMove, interval);
			}).click(function (ev) {
				//=>基于事件委托实现焦点和左右按钮点击
				let target = ev.target,
					$target = $(target);
				//=>事件源：焦点
				if (target.tagName === "SPAN" && $target.parent().hasClass('pagination')) {
					activeIndex = $target.index();
					change();
					return;
				}
				//=>事件源：前进后退按钮
				if (target.tagName === 'A') {
					if ($target.hasClass('button-prev')) {
						activeIndex--;
						activeIndex < 0 ? activeIndex = count - 1 : null;
						change();
						return;
					}
					if ($target.hasClass('button-next')) {
						autoMove();
						return;
					}
				}
			});
			//=>在真实项目中，如果要操作的元素是基于JS动态绑定的，那么“相关事件行为触发做些事情”的处理操作，我们尽可能基于事件委托来处理（事件委托可以给动态绑定的元素绑定事件）
		}
	}
})();
bannerModule.init();
~~~





## 三十.深度封装轮播图插件

### 参照SWIPER实现轮播图插件封装

> **基于ES6进行插件封装，这个是重点也是难点内容，知识体系不难，各种参数配置和业务逻辑处理偏难**

- JQUERY插件的扩展（依赖JQUERY库）
  - 封装思想：闭包的应用
  - $.fn.extend  &  $.extend
  - 基于JQ封装插件不是重点，不做过多参数设计，实现功能即可
- 基于ES6和原生JS实现轮播图插件封装（不依赖任何类库） 
  - 封装思想：面向对象 （同时对比此方式和闭包方式的区别及优势）
  - 拟定参数配置项
    - 插件封装第一要素：灵活且功能强大，尽可能多的适配不同应用场景和需求
    - 插件封装第二要素：容错性和可扩展性要强（传参要采用对象配置的方式和参数初始化处理）
    - 插件封装第三要素：追求极致的性能和优秀的代码管理方式
    - 插件封装第四要素：开源，并且依赖社区力量不断的去完善
    - ......
  - 按步骤依次实现轮播图应该具备的功能
  - 增加生命周期函数（钩子函数）
  - 编写插件使用说明文档

```js
let example = new Banner([selector|element],[options]);

//=>options的配置内容
options={
  initialSlide:0, //=>初始展示slide的索引
    speed:300, //=>切换动画的速度
    autoplay:3000, //=>每间隔3000ms自动切换一次
  pagination:{ //=>设置分页器
        el:'.pagination',
        //=>焦点操作是否触发轮播图切换，不设置则为不触发，想要触发请给出触发事件类型
        triggerEvent:'click' 
    },
    navigation:{  //=>设置前进后退按钮
      nextEl:'.button-next',
      prevEl:'.button-prev',
      hide:true, //=>默认是隐藏的，鼠标进入容器中才显示
    },
    //=>设置生命周期函数（钩子函数）
    on:{
        //=>初始化成功
        init:function(examp){
            //=>this:当前创建的Banner类的实例
            //=>examp等同于this
        },
        //=>切换动画运动开始
        transitionStart:function(examp){},
        //=>切换动画运动完成
        transitionEnd:function(examp){}
    }
}
```

### 插件组件封装的一点思想

1. 基于面向对象的方式来处理

​    =>调取一次插件相当于创建插件的一个实例

​    =>这样私有的可以设置，公有的方法也可以设置

2. 我们要保证几个事情

​    =>灵活且功能强大（适配更多的应用场景）

​    =>容错性和可扩展性要强

​    =>追求极致的性能和优秀的代码管理方式

​    =>开源精神

###  轮播图插件封装

#### index.html

~~~html
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>渐隐渐现版轮播图</title>
	<!-- IMPORT CSS -->
	<link rel="stylesheet" href="css/reset.min.css">
	<link rel="stylesheet" href="css/banner.css">
</head>
<!-- 
	插件组件封装的一点思想：
	1. 基于面向对象的方式来处理
	  =>调取一次插件相当于创建插件的一个实例
	  =>这样私有的可以设置，公有的方法也可以设置
	2. 我们要保证几个事情
	  =>灵活且功能强大（适配更多的应用场景）
	  =>容错性和可扩展性要强
	  =>追求极致的性能和优秀的代码管理方式
	  =>开源精神
 -->

<body>
	<section class="container" id="container1">
		<!-- 轮播图容器 -->
		<div class="wrapper"></div>
		<!-- 分页器容器 -->
		<div class="pagination"></div>
	</section>

	<section class="container" id="container2">
		<!-- 轮播图容器 -->
		<div class="wrapper"></div>
		<!-- 前进后退按钮 -->
		<a href="javascript:;" class="button-prev"></a>
		<a href="javascript:;" class="button-next"></a>
	</section>

	<!-- IMPORT JS -->
	<!-- <script src="js/jquery.min.js"></script>
	<script src="js/banner-plugin-jquery.js"></script>
	<script src="js/banner.js"></script> -->

	<script src="js/jquery.min.js"></script>
	<script src="js/banner-plugin.min.js"></script>
	<script src="js/banner.js"></script>
</body>

</html>
~~~

#### reset.min.css

~~~css
body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,button,input,textarea,th,td{margin:0;padding:0}body{font-size:12px;font-style:normal;font-family:"\5FAE\8F6F\96C5\9ED1",Helvetica,sans-serif}small{font-size:12px}h1{font-size:18px}h2{font-size:16px}h3{font-size:14px}h4,h5,h6{font-size:100%}ul,ol{list-style:none}a{text-decoration:none;background-color:transparent}a:hover,a:active{outline-width:0;text-decoration:none}table{border-collapse:collapse;border-spacing:0}hr{border:0;height:1px}img{border-style:none}img:not([src]){display:none}svg:not(:root){overflow:hidden}html{-webkit-touch-callout:none;-webkit-text-size-adjust:100%}input,textarea,button,a{-webkit-tap-highlight-color:rgba(0,0,0,0)}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]),video:not([controls]){display:none;height:0}progress{vertical-align:baseline}mark{background-color:#ff0;color:#000}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}button,input,select,textarea{font-size:100%;outline:0}button,input{overflow:visible}button,select{text-transform:none}textarea{overflow:auto}button,html [type="button"],[type="reset"],[type="submit"]{-webkit-appearance:button}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0}button:-moz-focusring,[type="button"]:-moz-focusring,[type="reset"]:-moz-focusring,[type="submit"]:-moz-focusring{outline:1px dotted ButtonText}[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0}[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{height:auto}[type="search"]{-webkit-appearance:textfield;outline-offset:-2px}[type="search"]::-webkit-search-cancel-button,[type="search"]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}.clearfix:after{display:block;height:0;content:"";clear:both}
~~~

#### banner.css

~~~css
.container {
	box-sizing: border-box;
	position: relative;
	margin: 20px auto;
	width: 1226px;
	height: 460px;
	overflow: hidden;
}

.container .wrapper {
	position: relative;
	height: 100%;
}

.container .wrapper .slide {
	position: absolute;
	top: 0;
	left: 0;
	box-sizing: border-box;
	width: 100%;
	height: 100%;
	z-index: 0;
	opacity: 0;
}

.container .wrapper .slide:nth-child(1) {
	z-index: 1;
	opacity: 1;
}

.container .wrapper .slide img {
	width: 100%;
	height: 100%;
}

.container .wrapper .slide span{
	display: block;
	transform: translateY(-100px);
	font-size: 30px;
	color: red;
}

.container .pagination {
	position: absolute;
	right: 20px;
	bottom: 20px;
	z-index: 999;
	font-size: 0;
}

.container .pagination span {
	display: inline-block;
	margin: 0 4px;
	width: 6px;
	height: 6px;
	background: rgba(0, 0, 0, .4);
	border: 2px solid rgba(255, 255, 255, .4);
	border-radius: 50%;
	cursor: pointer;
}

.container .pagination span.active {
	background: rgba(255, 255, 255, .4);
	border-color: rgba(0, 0, 0, .4);
}

.container .button-prev,
.container .button-next {
	position: absolute;
	top: 50%;
	margin-top: -35px;
	z-index: 999;
	width: 40px;
	height: 70px;
	background: url("../images/icon-slides.png") no-repeat;
}

.container .button-prev {
	left: 0;
	background-position: -83px 0;
}

.container .button-prev:hover {
	background-position: 0 0;
}

.container .button-next {
	right: 0;
	background-position: -124px 0;
}

.container .button-next:hover {
	background-position: -41px 0;
}
~~~

#### banner.js

~~~javascript
let $container1 = $('#container1'),
	$container2 = $('#container2');

//=>第一个轮播图数据绑定
$.ajax({
	url: 'json/bannerData1.json',
	method: 'get',
	success: result => {
		let str1 = ``;
		result.forEach((item, index) => {
			str1 += `<div class="slide">
				<img src="${item.pic}" alt="">
			</div>`;
		});
		$container1.find('.wrapper').html(str1);

		//=>实现轮播效果
		// $container1.bannerPlugin();	
		new Banner('#container1', {
			initialSlide: 3,
			autoplay: 2000,
			pagination: {
				triggerEvent: 'mouseover'
			},
			navigation: null,
			on: {
				/* init: function () {
					console.log('初始化成功了');
				},
				transitionStart: function () {
					console.log('动画开始~~');
				}, */
				transitionEnd: function (examp) {
					//=>this===examp===实例
					// let active = this.slideList[this.activeIndex];
					// active.innerHTML += `<span>我是第${this.activeIndex+1}个SLIDE</span>`;
				}
			}
		});
	}
});

//=>第二个轮播图数据绑定
$.ajax({
	url: 'json/bannerData2.json',
	method: 'get',
	success: result => {
		let str1 = ``;
		result.forEach((item, index) => {
			str1 += `<div class="slide">
				<img src="${item.pic}" alt="">
			</div>`;
		});
		$container2.find('.wrapper').html(str1);

		//=>实现轮播效果
		// $container2.bannerPlugin();
		new Banner('#container2', {
			autoplay: null,
			pagination: null
		});
	}
});
~~~

#### banner-plugin-jquery.js

~~~javascript
/*
 * JQUERY：extend  向JQ内部扩展方法
 *    //=>向JQ的原型上扩展方法[写插件]
 *    $.fn.extend({ xxx:function(){} }) 
 *    $('.box').xxx();
 *    
 *    //=>向JQ对象中增加私有的属性方法[完善类库,提供更多工具类方法]
 *    $.extend({ xxx:function(){} })
 *    $.xxx();
 */
~ function ($) {
	if (typeof $ === 'undefined') {
		//=>throw new Error() 抛出浏览器异常信息,此时下面代码不在执行
		throw new Error('当前插件必须依托JQUERY才可以实现~~');
	}

	//=>THROTTLE:函数节流
	function throttle(func, wait) {
		let timer = null,
			result = null,
			previous = 0;
		return function anonymous(...args) {
			let context = this,
				now = new Date,
				spanTime = wait - (now - previous);
			if (spanTime <= 0) {
				result = func.call(context, ...args);
				clearTimeout(timer);
				timer = null;
				previous = now;
			} else if (!timer) {
				timer = setTimeout(() => {
					result = func.call(context, ...args);
					timer = null;
					previous = new Date;
				}, spanTime);
			}
			return result;
		}
	}

	//=>BANNER-PLUGIN:只封装和轮播图相关的功能（自动轮播、焦点触发、左右按钮）
	function bannerPlugin() {
		//=>this:要实现轮播图的容器(原生JS对象)
		let $this = $(this),
			$wrapper = $this.find('.wrapper'),
			$pagination = $this.find('.pagination'),
			$buttonPrev = $this.find('.button-prev'),
			$buttonNext = $this.find('.button-next'),
			$slideList = $wrapper.find('.slide'),
			$paginationList = $pagination.find('span');

		let autoTimer = null,
			interval = 1000,
			speed = 300,
			activeIndex = 0,
			count = $slideList.length;

		let change = function () {
			let $active = $slideList.eq(activeIndex),
				$siblings = $active.siblings();
			$active.css('transition', `opacity ${speed}ms`);
			$siblings.css('transition', `opacity 0ms`);
			$active.css('z-index', 1);
			$siblings.css('z-index', 0);
			$active.css('opacity', 1).on('transitionend', function () {
				$siblings.css('opacity', 0);
			});

			//=>焦点对齐
			$paginationList.each((index, item) => {
				let $item = $(item);
				if (index === activeIndex) {
					$item.addClass('active');
					return;
				}
				$item.removeClass('active');
			});
		};

		let autoMove = function () {
			activeIndex++;
			activeIndex >= count ? activeIndex = 0 : null;
			change();
		};

		let handlePagination = function () {
			$paginationList.mouseover(throttle(function () {
				activeIndex = $(this).index();
				change();
			}, 500));
		};

		let handleButton = function () {
			$buttonNext.click(throttle(autoMove, 300));
			$buttonPrev.click(throttle(function () {
				activeIndex--;
				activeIndex < 0 ? activeIndex = count - 1 : null;
				change();
			}, 500));
		};

		autoTimer = setInterval(autoMove, interval);
		handlePagination();
		handleButton();
		$this.mouseenter(() => clearInterval(autoTimer))
			.mouseleave(() => autoTimer = setInterval(autoMove, interval));
	}


	$.fn.extend({
		//=>bannerPlugin:bannerPlugin
		bannerPlugin
	});
}(jQuery);
~~~

#### banner-plugin.js

~~~js
/*
 * 细节知识点：
 *   1.我们封装公共方法的时候，如果需要传递的参数过多（超过两个就可以理解为多了），则不要定义为形参，让用户依次传递，这样会受到 顺序、传或者不传 等因素的影响，管理起来很复杂；我们可以把需要传递的值统一放到一个对象中（一般都是options），这样我们传递的信息可传可不传，顺序也随便，最后把传递的信息覆盖默认的信息即可，方便管理，也方便进行二次扩展
 *   
 *   2.我们把后期需要用到的信息都挂载到当前类的实例上，这样后面不管在哪个方法中用这些信息，只要能获取到实例，直接通过实例获取即可
 *   
 *   3.本插件中需要使用的工具类方法，我们一把放到类的私有属性上（普通对象）
 */

~ function () {
	/* Banner：渐隐渐现轮播图插件 */
	class Banner {
		constructor(selector, options = {}) {
			//=>参数初始化
			this.initialParams(options);

			//=>获取需要操作的容器
			if (!selector) throw new ReferenceError('The first selector parameter must be passed~~');
			if (typeof selector === "string") {
				this.container = document.querySelector(selector);
			} else if (selector.nodeType) {
				this.container = selector;
			}
			this.wrapper = this.container.querySelector('.wrapper');
			this.slideList = this.wrapper.querySelectorAll('.slide');
			this.autoTimer = null;
			this.activeIndex = this.initialSlide;
			this.count = this.slideList.length;

			//=>初始展示SLIDE
			[].forEach.call(this.slideList, (item, index) => {
				if (index === this.initialSlide) {
					item.style.zIndex = 1;
					item.style.opacity = 1;
					return;
				}
				item.style.zIndex = 0;
				item.style.opacity = 0;
			});

			//=>自动轮播处理
			if (this.autoplay) {
				let anonymous = this.autoMove.bind(this);
				this.autoTimer = setInterval(anonymous, this.autoplay);
				this.container.addEventListener('mouseenter', () => {
					clearInterval(this.autoTimer);
				});
				this.container.addEventListener('mouseleave', () => {
					this.autoTimer = setInterval(anonymous, this.autoplay);
				});
			}

			//=>分页器的处理
			if (this.pagination && this.pagination.el) {
				this.handlePagination();
			}

			//=>前进和后退按钮处理
			if (this.navigation) {
				this.handleButton();
			}

			//=>钩子函数的处理
			//=>初始化成功
			this.on && this.on.init && this.on.init.call(this, this);
		}
		/*===Banner.prototype===*/
		/*
		 * initialParams：初始化插件的参数配置信息
		 */
		initialParams(options) {
			//1.首先设置默认的参数信息
			let _default = {
				initialSlide: 0,
				speed: 300,
				autoplay: 3000,
				pagination: {
					el: '.pagination',
					triggerEvent: 'click'
				},
				navigation: {
					nextEl: '.button-next',
					prevEl: '.button-prev',
					hide: true
				},
				on: {
					init: function (examp) {},
					transitionStart: function (examp) {},
					transitionEnd: function (examp) {}
				}
			};
			//2.把传递进来的OPTIONS中的信息替换_DEFAULT中的信息
			for (let key in options) {
				if (!options.hasOwnProperty(key)) break;
				if (/^(pagination|navigation|on)$/i.test(key)) continue;
				_default[key] = options[key];
			}
			//=>pagination
			let pagination = options.pagination;
			if (pagination !== null) {
				pagination = pagination || {};
				for (let key in pagination) {
					if (!pagination.hasOwnProperty(key)) break;
					_default['pagination'][key] = pagination[key];
				}
			} else {
				_default['pagination'] = null;
			}

			//=>navigation
			let navigation = options.navigation;
			if (navigation !== null) {
				navigation = navigation || {};
				for (let key in navigation) {
					if (!navigation.hasOwnProperty(key)) break;
					_default['navigation'][key] = navigation[key];
				}
			} else {
				_default['navigation'] = null;
			}

			//=>on
			let _on = options.on;
			if (_on !== null) {
				_on = _on || {};
				for (let key in _on) {
					if (!_on.hasOwnProperty(key)) break;
					_default['on'][key] = _on[key];
				}
			} else {
				_default['on'] = null;
			}

			//3.把处理好的信息挂载到实例上
			for (let key in _default) {
				if (!_default.hasOwnProperty(key)) break;
				this[key] = _default[key];
			}
		}

		/* 实现轮播图切换 */
		change() {
			[].forEach.call(this.slideList, (item, index) => {
				if (index === this.activeIndex) {
					//=>当前要操作的SLIDE
					item.style.transition = `opacity ${this.speed}ms`;
					item.style.zIndex = 1;
					return;
				}
				//=>其余的SLIDE
				item.style.transition = `opacity 0ms`;
				item.style.zIndex = 0;
			});
			//=>开始动画
			//=>动画开始前的钩子函数
			this.on && this.on.transitionStart && this.on.transitionStart.call(this, this);
			let active = this.slideList[this.activeIndex];
			active.style.opacity = 1;
			active.addEventListener('transitionend', () => {
				//=>addEventListener:DOM2级事件绑定
				[].forEach.call(this.slideList, (item, index) => {
					if (index !== this.activeIndex) {
						item.style.opacity = 0;
					}
				});
				//=>动画结束后的钩子函数
				this.on && this.on.transitionEnd && this.on.transitionEnd.call(this, this);
			});
			//=>焦点对齐
			if (this.paginationList) {
				[].forEach.call(this.paginationList, (item, index) => {
					if (index === this.activeIndex) {
						item.className = "active";
						return;
					}
					item.className = "";
				});
			}
		}

		/* 自动轮播 */
		autoMove() {
			this.activeIndex++;
			this.activeIndex >= this.count ? this.activeIndex = 0 : null;
			this.change();
		}

		/* 分页器处理 */
		handlePagination() {
			//=>获取分页器盒子，动态创建内容
			this.paginationBox = this.container.querySelector(this.pagination.el);
			let str = ``;
			for (let i = 0; i < this.count; i++) {
				str += `<span class='${i===this.activeIndex?'active':''}'></span>`;
			}
			this.paginationBox.innerHTML = str;
			this.paginationList = this.paginationBox.querySelectorAll('span');

			//=>是否焦点触发切换
			if (this.pagination.triggerEvent) {
				[].forEach.call(this.paginationList, (item, index) => {
					item.addEventListener(this.pagination.triggerEvent, Banner.throttle(() => {
						this.activeIndex = index;
						this.change();
					}, 500));
				});
			}
		}

		/* 前进后退按钮 */
		handleButton() {
			this.prevEl = this.container.querySelector(this.navigation.prevEl);
			this.prevEl.addEventListener('click', Banner.throttle(() => {
				this.activeIndex--;
				this.activeIndex < 0 ? this.activeIndex = this.count - 1 : null;
				this.change();
			}, 500));

			this.nextEl = this.container.querySelector(this.navigation.nextEl);
			this.nextEl.addEventListener('click', Banner.throttle(this.autoMove.bind(this), 500));

			//=>显示隐藏的处理
			if (this.navigation.hide) {
				this.prevEl.style.display = 'none';
				this.nextEl.style.display = 'none';
				this.container.addEventListener('mouseenter', () => {
					this.prevEl.style.display = 'block';
					this.nextEl.style.display = 'block';
				});
				this.container.addEventListener('mouseleave', () => {
					this.prevEl.style.display = 'none';
					this.nextEl.style.display = 'none';
				});
			}
		}

		/*===设置私有的方法===*/
		static throttle(func, wait) {
			let timer = null,
				result = null,
				previous = 0;
			return function anonymous(...args) {
				let context = this,
					now = new Date,
					spanTime = wait - (now - previous);
				if (spanTime <= 0) {
					result = func.call(context, ...args);
					clearTimeout(timer);
					timer = null;
					previous = now;
				} else if (!timer) {
					timer = setTimeout(() => {
						result = func.call(context, ...args);
						timer = null;
						previous = new Date;
					}, spanTime);
				}
				return result;
			}
		}
	}

	window.Banner = Banner;
}();


/* 
 * 枚举属性（可枚举或者不可枚举） 
 * =>在FOR IN遍历循环的时候，可以被迭代到的属性是可枚举的，反之是不可枚举的
 * =>可枚举的：
 * 1. 一般自己设置的私有属性和方法 或者 自己设置的公有属性和方法 都是可枚举的
 */
/* Object.prototype.AAA = "沅芷澧兰";
let obj = {
	name: '沅芷',
	year: 10
	// __proto__:Object.prototype
};
for (let key in obj) {
	if (!obj.hasOwnProperty(key)) break;
	console.log(key);
} */
~~~

#### banner-plugin.min.js（压缩）

~~~js
"use strict";function _classCallCheck(t,i){if(!(t instanceof i))throw new TypeError("Cannot call a class as a function")}var _createClass=function(){function t(t,i){for(var n=0;n<i.length;n++){var e=i[n];e.enumerable=e.enumerable||!1,e.configurable=!0,"value"in e&&(e.writable=!0),Object.defineProperty(t,e.key,e)}}return function(i,n,e){return n&&t(i.prototype,n),e&&t(i,e),i}}();~function(){var t=function(){function t(i){var n=this,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(_classCallCheck(this,t),this.initialParams(e),!i)throw new ReferenceError("The first selector parameter must be passed~~");if("string"==typeof i?this.container=document.querySelector(i):i.nodeType&&(this.container=i),this.wrapper=this.container.querySelector(".wrapper"),this.slideList=this.wrapper.querySelectorAll(".slide"),this.autoTimer=null,this.activeIndex=this.initialSlide,this.count=this.slideList.length,[].forEach.call(this.slideList,function(t,i){if(i===n.initialSlide)return t.style.zIndex=1,void(t.style.opacity=1);t.style.zIndex=0,t.style.opacity=0}),this.autoplay){var a=this.autoMove.bind(this);this.autoTimer=setInterval(a,this.autoplay),this.container.addEventListener("mouseenter",function(){clearInterval(n.autoTimer)}),this.container.addEventListener("mouseleave",function(){n.autoTimer=setInterval(a,n.autoplay)})}this.pagination&&this.pagination.el&&this.handlePagination(),this.navigation&&this.handleButton(),this.on&&this.on.init&&this.on.init.call(this,this)}return _createClass(t,[{key:"initialParams",value:function(t){var i={initialSlide:0,speed:300,autoplay:3e3,pagination:{el:".pagination",triggerEvent:"click"},navigation:{nextEl:".button-next",prevEl:".button-prev",hide:!0},on:{init:function(t){},transitionStart:function(t){},transitionEnd:function(t){}}};for(var n in t){if(!t.hasOwnProperty(n))break;/^(pagination|navigation|on)$/i.test(n)||(i[n]=t[n])}var e=t.pagination;if(null!==e){e=e||{};for(var a in e){if(!e.hasOwnProperty(a))break;i.pagination[a]=e[a]}}else i.pagination=null;var o=t.navigation;if(null!==o){o=o||{};for(var s in o){if(!o.hasOwnProperty(s))break;i.navigation[s]=o[s]}}else i.navigation=null;var r=t.on;if(null!==r){r=r||{};for(var l in r){if(!r.hasOwnProperty(l))break;i.on[l]=r[l]}}else i.on=null;for(var c in i){if(!i.hasOwnProperty(c))break;this[c]=i[c]}}},{key:"change",value:function(){var t=this;[].forEach.call(this.slideList,function(i,n){if(n===t.activeIndex)return i.style.transition="opacity "+t.speed+"ms",void(i.style.zIndex=1);i.style.transition="opacity 0ms",i.style.zIndex=0}),this.on&&this.on.transitionStart&&this.on.transitionStart.call(this,this);var i=this.slideList[this.activeIndex];i.style.opacity=1,i.addEventListener("transitionend",function(){[].forEach.call(t.slideList,function(i,n){n!==t.activeIndex&&(i.style.opacity=0)}),t.on&&t.on.transitionEnd&&t.on.transitionEnd.call(t,t)}),this.paginationList&&[].forEach.call(this.paginationList,function(i,n){if(n===t.activeIndex)return void(i.className="active");i.className=""})}},{key:"autoMove",value:function(){this.activeIndex++,this.activeIndex>=this.count&&(this.activeIndex=0),this.change()}},{key:"handlePagination",value:function(){var i=this;this.paginationBox=this.container.querySelector(this.pagination.el);for(var n="",e=0;e<this.count;e++)n+="<span class='"+(e===this.activeIndex?"active":"")+"'></span>";this.paginationBox.innerHTML=n,this.paginationList=this.paginationBox.querySelectorAll("span"),this.pagination.triggerEvent&&[].forEach.call(this.paginationList,function(n,e){n.addEventListener(i.pagination.triggerEvent,t.throttle(function(){i.activeIndex=e,i.change()},500))})}},{key:"handleButton",value:function(){var i=this;this.prevEl=this.container.querySelector(this.navigation.prevEl),this.prevEl.addEventListener("click",t.throttle(function(){i.activeIndex--,i.activeIndex<0&&(i.activeIndex=i.count-1),i.change()},500)),this.nextEl=this.container.querySelector(this.navigation.nextEl),this.nextEl.addEventListener("click",t.throttle(this.autoMove.bind(this),500)),this.navigation.hide&&(this.prevEl.style.display="none",this.nextEl.style.display="none",this.container.addEventListener("mouseenter",function(){i.prevEl.style.display="block",i.nextEl.style.display="block"}),this.container.addEventListener("mouseleave",function(){i.prevEl.style.display="none",i.nextEl.style.display="none"}))}}],[{key:"throttle",value:function(t,i){var n=null,e=null,a=0;return function(){for(var o=arguments.length,s=Array(o),r=0;r<o;r++)s[r]=arguments[r];var l=this,c=new Date,h=i-(c-a);return h<=0?(e=t.call.apply(t,[l].concat(s)),clearTimeout(n),n=null,a=c):n||(n=setTimeout(function(){e=t.call.apply(t,[l].concat(s)),n=null,a=new Date},h)),e}}}]),t}();window.Banner=t}();
~~~















