# 第二周

## 十八.this

### this初步

> 函数执行的主体（不是上下文）：意思是谁把函数执行的，那么执行函数主体就是谁
>
> THIS非常不好理解，以后遇到this，想一句话：“你以为你以为的就是你以为的”

1. 给元素的某个事件绑定方法，当事件触发方法执行的时候，方法中的this是当前操作的元素本身
2. 如何确定执行主体是谁？当方法执行的时候，我们看方法前面是否有点，没有点this是window或者undefined；有点，点前面是谁this就是谁

```javascript
var name='沅芷澧兰';
function fn(){
    console.log(this.name);
}
var obj={
    name:"你好世界",
    fn:fn
};
obj.fn(); //=>this:obj
fn(); //=>this:window（非严格模式，严格模式下是undefined） window.fn()把window.省略了

(function(){
	//自执行函数中的this是window或undefined    
})();
```

**this问题**

```js
// this问题
/* document.body.onclick = function () {
	// this:document.body
	fn();//=>this:window
}
var obj={
	aa:fn
};
function fn(){
	console.log(this);
}
fn();//=>window
obj.aa();//=>this:obj */

/* 
 * 代码执行
 *   第一步：创建obj
 *   第二步：创建堆存储值
 *       1.属性名fn
 *       2.属性值:自执行函数执行的返回结果给fn（返回的小函数）
 *   第三步：obj和值关联
 */
/* let obj = {
	fn: (function () {
		// this:window
		return function () {
			console.log(this);
		}
	})()
};
obj.fn(); //=>this.obj
let fn = obj.fn; //=>把小函数给fn
fn(); //=>this:window */
```

**思考？**

```js
//=>hasOwnProperty方法中的this：ary.__proto__.__proto__
ary.__proto__.__proto__.hasOwnProperty()

let obj={
    fn:(function(n){
       //把自执行函数执行的返回结果赋值给fn
       //this:window
       return function(){
           //=>fn等于这个返回的小函数
           //this:obj
       };
    })(10)
};
obj.fn();


function fn(){
    //this:window
    console.log(this);
}
document.body.onclick=function(){
    //this:document.body
    fn();
}
```

### this&一些面向对象面试题及细节知识点

```JS
/*
 * THIS是函数执行的主体（谁执行的） 
 *    THIS是谁和函数在哪创建的或者在哪执行的都没有必然的联系
 * 
 * 掌握几条分清执行的主体的规律
 * 	  1.给元素的某个事件绑定方法，当事件触发方法执行的时候，方法中的THIS是当前操作的元素
 *    2.方法执行，看方法前面是否有点，有点，点前面是谁THIS就是谁，没有点THIS是WINDOW（在严格模式下没有点THIS是UNDEFINED  =>"use strict"）
 *    3.在构造函数模式执行中，函数体中的THIS是当前类的实例
 */


/* document.body.onclick = function () {
	//this:BODY
} */
/* function fn() {
	console.log(this);
}
let obj = {
	fn: fn
};
fn();//=>this:window
obj.fn();//=>this:obj */
/* 
function Fn() {
	// this:f这个实例
	this.name = 'xxx';
}
let f = new Fn();
console.log(f.name); */



//====================================
/* var fullName = 'language';
var obj = {
	fullName: 'javascript',
	prop: {
		getFullName: function () {
			return this.fullName;
		}
	}
};
console.log(obj.prop.getFullName());
//=>this:obj.prop  =>return obj.prop.fullName  =>undefined
var test = obj.prop.getFullName;
console.log(test());
//=>this:window  =>return window.fullName  =>"language" */


/* var name = 'window';
var Tom = {
	name: "Tom",
	show: function () {
		console.log(this.name);
	},
	wait: function () {
		// this:Tom  
		var fun = this.show; 
		//=>Tom.show

		fun();
		//=>this:window  =>console.log(window.name)  =>"window"
	}
};
Tom.wait(); */



/* window.val = 1;
var json = {
	val: 10,
	dbl: function () {
		this.val *= 2;
	}
}
json.dbl();
//=>this:json  =>json.val *= 2  =>json.val=20

var dbl = json.dbl;
dbl();
//=>this:window  =>window.val *= 2  =>window.val=2

json.dbl.call(window);
//=>this:window（基于call方法改的）  =>window.val=4

alert(window.val + json.val);
//=>"24" */


/* var val = 1;
var json = {
	val: 10,
	dbl: function () {
		// 上级作用域（栈不是堆），所以是全局作用域
		val *= 2; //=>全局val=2
	}
};
json.dbl();
alert(json.val + val); //=>"12" */


/* var val = 1;
var json = {
	val: 10,
	dbl: function () {
		//this:json
		this.val *= 2; //=>json.val=20
	}
};
json.dbl();
alert(json.val + val); //=>"21" */


/* var num = 10;
var obj = {num: 20};
obj.fn = (function (num) {
    this.num = num * 3;
    num++;
    return function (n) {
        this.num += n;
        num++;
        console.log(num);
    }
})(obj.num);
var fn = obj.fn;
fn(5);
obj.fn(10);
console.log(num, obj.num); */
```

![2-1-1](C:\Users\左海之浅\Desktop\课程笔记\图片文件\2-1-1.png)

## 十九.面向对象&原型链

### 面向对象&原型链

#### 面向对象

> 标记语言：HTML5/CSS3
>
> 编程语言：编程思想
>
> - 面向过程：比如C 是以过程为核心，它关注眼下要解决的问题。现在有一个功能要实现，就写一段代码来实现。它不关心过去是否有过类似的功能，未来是否还有类似的功能。
> - 面向对象： 比如Java、PHP、C#（ASP.NET）、JavaScript......  是一种对现实世界的理解和抽象方法。面向对象关心现有问题分类解决，过去有没有写过类似的代码，现在可以复用；我们现在做的功能未来是不是还要用。

- 面向对象的研究范畴：
  - 对象：万物皆对象，每个对象都有各自的属性、特性和功能；
  - 类：抽象事物特性、属性，把事物分类。类是描述一群事物的属性、特性和功能的抽象概念；比如说动物类、植物类；学员类、老师类
  - 实例：类中的具体的一个个体。只要是这个类中的一个个体，就会有这个类所有的属性、特性和功能。
- 面向对象具体体现在哪里？
- 在数据类型，有一个对象类、数组类。数组类的属性和特性是：有序的、push、pop....数组方法，但是对象是无序的键值对集合

#### 单例设计模式

```js
let name='沅芷澧兰';
let age=20;
let sex='writer';

let name='零';
let age=19;
let sex='writea';

//=>把描述当前事务特征的信息进行分组归类（减少全局变量的污染）
//=>这就是JS中的单例设计模式
/*
 * A不仅仅被叫做变量（对象名），也被称为“命名空间”
 *    单例模式：把描述事物的信息放到一个命名空间中进行归组，防止全局变量的污染
 */
let A={
     name='沅芷澧兰';
	 age=20;
	 sex='writer';
};
let B={
     name='零';
	 age=19;
	 sex='writea';
};
```

> 为了让单例模式变得高大上一些，真实项目中的单例模式都是这样处理的

```javascript
function fn(){}
let namespace = (function(){
    //创建一些方法（闭包中的私有方法）
    let fn=function(){
      	//....  
    };
    ...
    return {
        name:'xxx',
        fn:fn
    }
})();
namespace.name
namespace.fn();
```

**例如**：完成一个需要团队协作开发的案例（百度首页）

```js
/*
 * 公共模块
 */
let utils=(function(){
    let queryElement=function(){...}
    
    return {
        //queryElement:queryElement
        queryElement
    }
})();

/*
 * xxx负责的页卡模块
 */
let pageTabModule=(function(){
    //=>获取元素（调取其它命名空间下的方法）
    let tabBox=utils.queryElement('.tabBox');
    let show=function(){...}
    ...
    return {
        init:function(){
            //调用自己模块下的方法
            show();
        }
    }
})();
pageTabModule.init();
    
...
```

#### 工厂模式

> 批量化生产：把实现某个功能的代码进行封装，后期在想实现这个功能，我们直接函数执行即可
>
> - 低耦合：减少页面中冗余的代码
> - 高内聚：提高代码的重复使用率

```js
function createPerson(name,age){
    let person={};
    person.name=name;
    person.age=age;
    return person;
}
let beautyGirl=createPerson('ZERO',18);
let oldMan=createPerson('YZLL',81);
beautyGirl.name
oldMan.name
...
```

#### 全面拥抱面向对象（Object Oriented Programming）

![什么是面向对象](C:\Users\左海之浅\Desktop\课程笔记\图片文件\什么是面向对象.png)

![JS也是基于面向对象构造出来的1](C:\Users\左海之浅\Desktop\课程笔记\图片文件\JS也是基于面向对象构造出来的1.png)

![JS也是基于面向对象构造出来的2](C:\Users\左海之浅\Desktop\课程笔记\图片文件\JS也是基于面向对象构造出来的2.png)

#### 构造原型模式（正统面向对象编程）

> 自己能够创造出自定义类和对应实例，构建起一套完整的面向对象模型

> new 方式可以构建类和实例
>
> ​	=>类：函数数据类型
>
> ​	=>实例：对象数据类型

```js
/* function CreatePerson(name, age) {
		this.name = name;
		this.age = age;
} */
// CreatePerson('张三', 25);//=>this:window  普通函数执行
// let person1 = new CreatePerson('和冉', 18);
/*
 * new CreatePerson()执行和普通函数执行的联系
 *   1.new这种执行方式叫做“构造函数执行模式”，此时的CreatePerson不仅仅是一个函数名，被称为“类”，而返回的结果（赋值给person1的）是一个对象，我们称之为“实例”，而函数体中出现的this都是这个实例
 */

function CreatePerson(name, age) {
	// this=>person1
	this.name = name;
	this.age = age;
	// return 100; //=>返回的还是实例
	// return {
	// 	xxx: 'xxx'
	// }; //=>如果手动RETURN的是一个基本值，对返回的实例无影响，如果手动RETURN的是一个引用类型的值，会把默认返回的实例给替换掉（所以在构造函数模式执行下，我们一般都不要手动写RETURN，防止把返回的实例给替换）
}
let person1 = new CreatePerson('HR', 18);
console.log(person1);
```

![构造函数模式执行](C:\Users\左海之浅\Desktop\课程笔记\图片文件\构造函数模式执行.png)

```javascript 
/*
 *  instanceof：用来检测某个实例是否属于这个类
 *     实例 instanceof 类，属于返回TRUE，不属于返回FALSE
 *  [局限性]
 *     要求检测的实例必须是对象数据类型的，基本数据类型的实例是无法基于它检测出来的   
 */
// console.log(person1 instanceof CreatePerson);//=>TRUE
/* let ary = [12, 23];
console.log(ary instanceof Array); //=>TRUE
console.log(ary instanceof RegExp); //=>FALSE
console.log(ary instanceof Object); //=>TRUE 
console.log(1 instanceof Number); //=>FALSE */

/*
 * 基本数据类型在JS中的特殊性
 *   1.一定是自己所属类的实例
 *   2.但是不一定是对象数据类型的 
 */
// 字面量创建方式（也是Number类的实例，也可以调取内置的公有方法）
// let n = 10;
// console.log(n.toFixed(2)); //=>'10.00'
// console.log(typeof n); //=>"number"

// 构造函数创建模式（创建出来的实例是对象类型的）
// let m = new Number("10");
// console.log(typeof m); //=>"object"
// console.log(m.toFixed(2)); //=>'10.00'

//==========================
// 构造函数执行，因为也具备普通函数执行的特点
// 1.和实例有关系的操作一定是 this.xxx=xxx ，因为this是当前类创造出来的实例
// 2.私有变量和实例没有必然的联系
function Fn(n) {
	let m = 10;
	this.total = n + m;
	this.say = function () {
		console.log(this.total);
	};
}
let f1 = new Fn(10);
let f2 = new Fn(20);
let f3 = new Fn; //=>new的时候不论是否加小括号，都相当于把Fn执行了，也创建了对应的实例，只不过不加小括号是不能传递实参的（当前案例中的形参n=undefined）
console.log(f1.m); //=>undefined
console.log(f2.n); //=>undefined
console.log(f1.total); //=>20
f2.say(); //=>this:f2（因为say执行前面有点） console.log(f2.total)=>30
console.log(f1 === f2); //=>FALSE（因为是两个不同的实例对象，也就是不同的堆地址）
```

![构造函数模式执行2](C:\Users\左海之浅\Desktop\课程笔记\图片文件\构造函数模式执行2.png)

> new执行也会把类当做普通函数执行（当然也有类执行的一面）
>
> 1. 创建一个私有的栈内存
> 2. 形参赋值&变量提升
> 3. 浏览器创建一个函数出来（这个对象就是当前类的一个实例），并且让函数中的this指向这个实例对象=>"构造函数模式中，方法中的this是当前类的实例"
> 4. 代码执行
> 5. 在我们不设置return的情况下，浏览器会把创建的实例对象默认返回

```js
/*
 * 类：函数数据类型
 * 实例：对象数据类型的
 */
function Fn() {
	/*
	 * NEW执行也会把类当做普通函数执行（当然也有类执行的一面）
	 *   1.创建一个私有的栈内存
	 *   2.形参赋值 & 变量提升
	 *   3.浏览器创建一个对象出来（这个对象就是当前类的一个新实例）,并且让函数中的THIS指向这个实例对象 =>“构造函数模式中，方法中的THIS是当前类的实例”
	 *   4.代码执行
	 *   5.在我们不设置RETURN的情况下，浏览器会把创建的实例对象默认返回 
	 */
	this.x = 100;
	this.y = 200;
	this.say = function () {}
}
Fn.prototype.eat = function () {}
Fn.prototype.say = function () {}

let f1 = new Fn();
let f2 = new Fn();
```

![构造原型模式（真正的面向对象编程）1 ](C:\Users\左海之浅\Desktop\课程笔记\图片文件\构造原型模式（真正的面向对象编程）1 .png)

#### 原型及原型链模式

1. 每一个函数数据类型的值都要一个天生自带的属性：prototype，这个属性 的属性值是一个对象（“用来存储实例公用的属性和方法的”）

   - 普通函数
   - 类（自定义类和内置类）

2. 在prototype这个对象中，有一个天生自带的属性：constructor，这个属性存储的是当前函数本身

   ```javascript
   Fn.prototype.constructor === Fn
   ```

3. 每一个对象数据类型的值，也有一个天生自带的属性：__ proto __，这个属性指向“所属类的原型prototype“

   - 普通对象、数组、正则、Math、日期、类数组等等
   - 实例也是对象数据类型的值
   - 函数的原型prototype属性的值也是对象数据类型的
   - 函数也是对象数据类型的值

![构造原型模式（真正的面向对象编程）2](C:\Users\左海之浅\Desktop\课程笔记\图片文件\构造原型模式（真正的面向对象编程）2.png)

##### 原型链查找机制

> 1. 先找自己私有的属性，有则调取使用，没有继续找
> 2. 基于__ proto __ 找所属类原型上的方法（Fn.prototype），如果还没有则继续基于__ proto __往上找...一直找到Object.prototype为止

![构造原型模式（真正的面向对象编程）3](C:\Users\左海之浅\Desktop\课程笔记\图片文件\构造原型模式（真正的面向对象编程）3.png)

![构造原型模式（真正的面向对象编程）4](C:\Users\左海之浅\Desktop\课程笔记\图片文件\构造原型模式（真正的面向对象编程）4.png)

**document的原型链**

![document原型链](C:\Users\左海之浅\Desktop\课程笔记\图片文件\document原型链.png)

##### hasOwnProperty

> 检测某一个属性名是否为当前对象的私有属性
>
> "in"：检测这个属性是否属于某个对象（不管是私有属性还是公有属性，只要是它的属性，结果就位true）

```js
let ary = [10,20,30];
console.log('0' in ary); //=>true
console.log('push' in ary); //=>true
console.log(ary.hasOwnProperty('0')); //=>true
console.log(ary.hasOwnProperty('push')); //=>false
"push"是它公有的属性不是私有的

console.log(Array.prototype.hasOwnProperty('push'));
//=>true 是公有还是所有属性，需要看相对谁来说的
console.log(Array.prototype.hasOwnProperty('hasOwnProperty'));
//=>false
console.log(Object.prototype.hasOwnProperty('hasOwnProperty'));
//=>true
//自己堆中有的就是私有属性，需要基于__proto__查找的就是公有属性（__proto__在IE浏览器中(edge除外)给保护起来了，不让我们在代码中操作它）
```

> 检测某个属性是否为对象的公有属性：hasPubProperty
>
> 方法：是它的属性，但不是私有的



##### 原型链方法中的this问题

```js
function Fn() {
	//=>this:f1这个实例
	this.x = 100;
	this.y = 200;
	this.say = function () {
		console.log(this.x);
	}
}
Fn.prototype.say = function () {
	console.log(this.y);
}
Fn.prototype.eat = function () {
	console.log(this.x + this.y);
}
Fn.prototype.write = function () {
	this.z = 1000;
}
let f1 = new Fn;
f1.say(); //=>this:f1   =>console.log(f1.x)  =>100
f1.eat(); //=>this:f1   =>console.log(f1.x + f1.y)  =>300
f1.__proto__.say(); //=>this:f1.__proto__  =>console.log(f1.__proto__.y)  =>undefined
Fn.prototype.eat(); //=>this:Fn.prototype  =>console.log(Fn.prototype.x + Fn.prototype.y)  =>NaN
f1.write(); //=>this:f1  =>f1.z=1000  =>给f1设置一个私有的属性z=1000
Fn.prototype.write();//=>this:Fn.prototype  =>Fn.prototype.z=1000  =>给原型上设置一个属性z=1000（属性是实例的公有属性）

/*
 * 面向对象中有关私有/公有方法中的THIS问题
 *   1.方法执行，看前面是否有点，点前面是谁THIS就是谁
 *   2.把方法中的THIS进行替换 
 *   3.再基于原型链查找的方法确定结果即可
 */
```

##### 基于内置类的原型扩展方法

```js
/*
 * 类：函数数据类型
 * 实例：对象数据类型的
 */
function Fn() {
	/*
	 * NEW执行也会把类当做普通函数执行（当然也有类执行的一面）
	 *   1.创建一个私有的栈内存
	 *   2.形参赋值 & 变量提升
	 *   3.浏览器创建一个对象出来（这个对象就是当前类的一个新实例）,并且让函数中的THIS指向这个实例对象 =>“构造函数模式中，方法中的THIS是当前类的实例”
	 *   4.代码执行
	 *   5.在我们不设置RETURN的情况下，浏览器会把创建的实例对象默认返回 
	 */
	this.x = 100;
	this.y = 200;
	this.say = function () {}
}
Fn.prototype.eat = function () {
	console.log('吃饭睡觉打豆豆');
}
Fn.prototype.say = function () {}

var f1 = new Fn();
var f2 = new Fn();



//基于内置类原型扩展方法 检测某个属性是否为对象的公有属性：hasPubProperty
Object.prototype.hasPubProperty = function (property) {
	//=>验证传递的属性名合法性（一般只能是数字或字符串等基本值）
	let x = ["string", "number", "boolean"],
		y = typeof property;
	if (!x.includes(y)) return false;
	//=>开始校验是否为公有的属性（方法中的THIS就是要校验的对象）
	let n = property in this,
		m = this.hasOwnProperty(property);
	return n && !m;
}
console.log(Array.prototype.hasPubProperty('push')); //=>FALSE
console.log([].hasPubProperty('push')); //=>TRUE




/*
 * 基于内置类的原型扩展方法 
 *   在内置类原型上的方法，类所对应的实例可以直接调取使用，例如：实例.方法()  ary.push()
 *   如果我们也把自己写的方法放到原型上，那么当前类的实例也可以直接这样调取使用了，很方便
 * 
 * 但是也有需要注意的地方
 * 	 1.自己扩展的方法不能影响原有内置的方法（我们自己设置的方法最好加前缀:my）
 *   2.扩展方法中的THIS一般都是当前类的实例（也就是要操作的值）：实例.方法()
 */
~ function () {
	/*
	 * myUnique : 实现数组去重
	 *   @params
	 *   @return
	 *      [Array] 去重后的数组
	 * by yuanzhililan on 20190805
	 */
	function myUnique() {
		//此时没有传递要操作的ARY进来，但是方法中的THIS是当前要操作的数组：ARY.MYUNIQUE()
		let obj = {};
		for (let i = 0; i < this.length; i++) {
			let item = this[i];
			if (typeof obj[item] !== 'undefined') {
				this[i] = this[this.length - 1];
				this.length--;
				i--;
				continue;
			}
			obj[item] = item;
		}
		obj = null;
		// 保证当前方法执行完返回的结果依然是ARRAY类的一个实例
		return this;
	}
	//=>扩展到内置类的原型上
	Array.prototype.myUnique = myUnique;
}();
let ary = [12, 23, 13, 12, 23, 24, 34, 13, 23];
// ary.myUnique(); 返回去重后的数组（也是ARRAY类的实例）
// ary.sort((a, b) => a - b); 返回排序后的数组
//=>链式写法（保证返回值依然是当前类的实例 一般都会RETURN THIS）
// ary.myUnique().sort((a, b) => a - b).reverse().slice(2).push('沅芷').concat(12);//=>Uncaught TypeError: ary.myUnique(...).sort(...).reverse(...).slice(...).push(...).concat is not a function  执行完push返回的是一个数字（新增后数组的长度），不是数组了，不能在继续使用数组的方法
ary.myUnique().sort((a, b) => a - b).reverse();
console.log(ary);




/* Array.prototype.push = function () {
	console.log("哈哈哈");
}
let ary = [1, 2, 3];
ary.push(100); //=>"哈哈哈"
console.log(ary); //=>数组没变*/
```

##### 重构类的原型

```js
/*
 * 重构类的原型：让某个类的原型指向新的堆内存地址（重定向指向）
 *    问题：重定向后的空间中不一定有CONSTRUCTOR属性（只有浏览器默认给PROTOTYPE开辟的堆内存中才存在CONSTRUCTOR），这样导致类和原型机制不完整；所以需要我们手动再给新的原型空间设置CONSTRUCTOR属性；   
 *    问题：在重新指向之前，我们需要确保原有原型的堆内存中没有设置属性和方法，因为重定向后，原有的属性和方法就没啥用了（如果需要克隆到新的原型堆内存中，我们还需要额外的处理） =>但是内置类的原型，由于担心这样的改变会让内置的方法都消失，所以禁止了我们给内置类原型的空间重定向，例如：Array.prototype={...}这样没有用，如果想加方法Array.prototype.xxx=function(){...}可以这样处理
 */
/* function Fn() {
	// ...
}
Fn.prototype.xxx = function () {}
//=>批量给原型设置属性方法的时候：重构类的原型
Fn.prototype = {
	constructor: Fn,
	getA: function () {},
	getB: function () {}
}; */

/* //=>批量给原型设置属性方法的时候：设置别名
let proto = Fn.prototype;
proto.getA = function () {}
proto.getB = function () {}
proto.getC = function () {}
proto.getD = function () {} */
```

##### 函数的三种角色

###### 函数有三种角色

1. 普通函数
   - 形参、实参、arguments、return、箭头函数
   - 私有作用域（栈内存、执行上下文）
   - 形参赋值 & 变量提升
   - 作用域链
   - 栈内存的释放和不释放（闭包）
   - ...
2. 构造函数（类）
   - 类和实例
   - prototype 和 __ proto __ 原型和原型链
   - instanceof
   - constructor
   - hasOwnProperty
   - ...
3. 普通对象
   - 它是由键值对组成的
   - ...

```js
/*
 * 函数数据类型：
 *   1. 普通函数
 *   2. 类（内置类 OR 自定义类）
 * 对象数据类型:
 *   1. {}普通对象  []数组对象  /^$/正则对象  日期对象  Math数学函数对象  arguments等类数组对象  HTMLCollection/NodeList元素或者节点集合类数组对象...
 *   2. 实例也是对象数据类型的
 *   3. 类的prototype也是对象数据类型的（Function.prototype除外,它是一个匿名空函数）
 *   4. 函数也是对象 
 * 
 * ======================================
 * 函数有三种角色
 *   1. 普通函数
 *     + 形参、实参、ARGUMENTS、RETURN、箭头函数
 *     + 私有作用域（栈内存、执行上下文）
 *     + 形参赋值 & 变量提升
 *     + 作用域链      
 *     + 栈内存的释放和不释放（闭包）
 *     + ...
 *   2. 构造函数（类）
 * 	   + 类和实例
 *     + prototype 和 __proto__ 原型和原型链
 *     + instanceof
 *     + constructor
 *     + hasOwnProperty
 *     + ...
 *   3. 普通对象
 *     + 它是由键值对组成的
 *     + ...
 *   函数中的THIS也是重点需要学习的内容
 */

function Fn(n, m) {
	this.x = n + m;
	this.y = n - m;
	let total = n * m;
	return total;
}
Fn.prototype.say = function () {
	console.log('SAY');
}

//=>普通函数
let total = Fn(20, 10);
//=>构造函数（类和实例）
let f = new Fn(20, 10);
//=>普通对象
Fn.total = 1000; 
```

![第二周/0806/函数的三种角色.png](C:\Users\左海之浅\Desktop\课程笔记\图片文件\函数的三种角色.png)

###### 函数三种角色的应用（jQuery源码的初步分析）

```js
 (function (global, factory) {
	//=>global:window（浏览器下运行） OR global（NODE下运行）
	//=>factory:function (window, noGlobal){...}
	"use strict";
	if (typeof module === "object" && typeof module.exports === "object") {
		//=>NODE下运行
		//...
	} else {
		//=>浏览器下运行
		factory(global);
	}
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
	//=>window:window
	//=>noGlobal:undefined
	var jQuery = function (selector, context) {
		return new jQuery.fn.init(selector, context);
	};

	var init;
	init = jQuery.fn.init = function (selector, context, root) {
		// ...
	};
	init.prototype = jQuery.fn = jQuery.prototype;

	if (!noGlobal) {
		//=>!undefined
		window.jQuery = window.$ = jQuery;
	}
}); 
/*
 * jQuery是一个构造函数:jQuery.prototype上有很多供实例操作的方法，例如css...
 *   $().css()
 * jQuery也是一个普通的对象，在它的堆空间中也存在很多的方法，例如ajax...
 *   $.ajax()
 */
// $(); //=>创建了jQuery这个类的一个实例，可以调取jQuery.prototype（jQuery.fn）上的方法
```

##### 原型练习题

###### 练习题一

```js
function Fn() {
	this.x = 100;
	this.y = 200;
	this.getX = function () {
		console.log(this.x);
	}
}
Fn.prototype.getX = function () {
	console.log(this.x);
};
Fn.prototype.getY = function () {
	console.log(this.y);
};
let f1 = new Fn;
let f2 = new Fn;
console.log(f1.getX === f2.getX);
console.log(f1.getY === f2.getY);
console.log(f1.__proto__.getY === Fn.prototype.getY);
console.log(f1.__proto__.getX === f2.getX);
console.log(f1.getX === Fn.prototype.getX);
console.log(f1.constructor);
console.log(Fn.prototype.__proto__.constructor);
f1.getX();
f1.__proto__.getX();
f2.getY();
Fn.prototype.getY(); 

// f1.__proto__.getX();
// ->找的是公有方法
// ->this:f1.__proto__===Fn.prototype
// ->console.log(f1.__proto__.x)
// ->undefined

// f2.getY();
// ->找的是公有方法
// ->this:f2
// ->console.log(f2.y)
// ->200

// Fn.prototype.getY()
// ->找的公有的方法
// ->this:Fn.prototype
// ->console.log(Fn.prototype.y)
// ->undefined

//=>基于CONSTRUCTOR实现数据类型检测就是这样来玩的
// 但是这种方式有很大的弊端：因为用户可以去随意修改对应的CONSTRUCTOR值或者是手动给ARY增加一个私有的CONSTRUCTOR属性等
// let ary = [];
// console.log(ary.constructor === Array); //=>TRUE
```

![第二周/0806/面向对象练习1.png](C:\Users\左海之浅\Desktop\课程笔记\图片文件\面向对象练习1.png)

###### 练习题二

```js
function fun(){
	this.a=0;
	this.b=function(){
		alert(this.a);
	}
}
fun.prototype={
	b:function(){
		this.a=20;
		alert(this.a);
	},
	c:function(){
		this.a=30;
		alert(this.a)
	}
}
var my_fun=new fun();
my_fun.b();
my_fun.c();
```

![第二周/0806/面向对象练习2.png](C:\Users\左海之浅\Desktop\课程笔记\图片文件\面向对象练习2.png)

###### 练习题三

```js
function C1(name) {
	// name:undefined
	if (name) { //条件不成立
		this.name = name;
	}
}
C1.prototype.name = 'Tom';
// new C1().name; 'Tom'

function C2(name) {
	// name:undefined
	this.name = name;// this.name=undefined;
}
C2.prototype.name = 'Tom';
// new C2().name  undefined

function C3(name) {
	// name:undefined
	this.name = name || 'join';// this.name = undefined || 'join' = 'join';
}
C3.prototype.name = 'Tom';
// new C3().name 'join'

alert((new C1().name) + (new C2().name) + (new C3().name)); //=>"Tomundefinedjoin"
```

###### 练习题四

```js
function Fn(num) {
	this.x = this.y = num;
}
Fn.prototype = {
	x: 20,
	sum: function () {
		console.log(this.x + this.y);
	}
};
let f = new Fn(10);
console.log(f.sum === Fn.prototype.sum);
f.sum();
Fn.prototype.sum();
console.log(f.constructor); 
```

![第二周/0806/面向对象练习4.png](C:\Users\左海之浅\Desktop\课程笔记\图片文件\面向对象练习4.png)

###### 练习题五

```javascript
function Fn() {
	let a = 1;
	this.a = a;
}
Fn.prototype.say = function () {
	this.a = 2;
}
Fn.prototype = new Fn;
let f1 = new Fn;
   
Fn.prototype.b = function () {
	this.a = 3;
};
console.log(f1.a);
console.log(f1.prototype);
console.log(f1.b);
console.log(f1.hasOwnProperty('b'));
console.log('b' in f1);
console.log(f1.constructor == Fn);
```

![第二周/0806/面向对象练习5.png](C:\Users\左海之浅\Desktop\课程笔记\图片文件\面向对象练习5.png)

```js
 function Fn() {
	this.x = 100;
 	this.y = 100;
 }
 Fn.prototype.getX = function () {
 	console.log(this.x);
 }
 let f1 = new Fn;
 Fn.prototype = {
 	getY: function () {
 		console.log(this.y);
 	}
 };
 let f2 = new Fn;
```

![第二周/0806/面向对象练习5-2.png](C:\Users\左海之浅\Desktop\课程笔记\图片文件\面向对象练习5-2.png)

###### 练习题六

```js
//编写两个方法 plus / minus 实现如下的执行效果
let n = 10;
let m = n.plus(10).minus(5);
console.log(m);//=>15（10+10-5）


~ function () {
	//=>x:需要加减的数字（必须是有效数字）
	function checkX(x) {
		x = Number(x);
		return isNaN(x) ? 0 : x;
	}

	function plus(x) {
		// this:我们要操作的原始值数字（this=xxx我们不能给THIS手动赋值）
		x = checkX(x);
		return this + x;
	}

	function minus(x) {
		x = checkX(x);
		return this - x;
	}

	/* 扩展到内置类的原型上 */
	Number.prototype.plus = plus;
	Number.prototype.minus = minus;
}();
let n = 10;
let m = n.plus(10).minus(5);
console.log(m); //=>15


// 思考题：重构数组的SLICE方法（不能用内置的），基于原生JS实现出和内置方法一模一样的效果
// N/M的各种情况
```

###### 练习题七

```js
// 阿里超经典面试题

 function Foo() {
     getName = function () {
         console.log(1);
     };
     return this;
 }
 Foo.getName = function () {
     console.log(2);
 };
 Foo.prototype.getName = function () {
     console.log(3);
 };
 var getName = function () {
     console.log(4);
 };
 function getName() {
     console.log(5);
 }
 Foo.getName();
 getName();
 Foo().getName();
 getName();
 new Foo.getName();
 new Foo().getName();
 new new Foo().getName();

//这个网址可以查看运算符优先级 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
```

![第二周/0806/函数的三种角色2.png](C:\Users\左海之浅\Desktop\课程笔记\图片文件\函数的三种角色2.png)



## 二十.THIS处理&ES6基础语法

### this（this的处理机制）

> 每一个函数（普通函数/构造函数/内置类）都是Function这个内置类的实例，所以：函数.__ proto __===Function.prototype，函数可以直接调取Function原型上的方法

~~~javascript
//Function.prototype => function anonymous(){}
/*
 * call / apply / bind  
 *    原型上提供的三个公有属性方法
 *    每一个函数都可以调用这个方法执行
 *    这些方法都是用来改变函数中的THIS指向的  
 */
function fn(){}
fn.call(); //=>fn函数基于原型链找到Function.prototype上的call方法，并且让其执行（执行的是call方法：方法中的this是fn）
fn.call.call(); //=>fn.call就是Function.prototype上的call方法，也是一个函数，只要是函数就能用原型上的方法，所以可以继续调用call来执行

/*
Function.prototype.call = function $1(){
    //...
}
fn.call => $1
fn.call() => $1()  this:fn
fn.call.call() => $1.call() => 继续让call执行,this:$1

实例.方法()：都是找到原型上的内置方法，让内置方法先执行（只不过执行的时候做了一些事情会对实例产生改变，而这也是这些内置方法的作用），内置方法中的THIS一般都是当前操作的实例
*/
~~~

#### call方法

> 语法：函数.call([context],[params1],....)
>
> 函数基于原型链找到Function.prototype.call这个方法，并且把它执行，在call方法执行的时候完成了一些功能
>
> - 让当前函数执行
> - 把函数中的this指向改为第一个传递给call的实参
> - 把传递给call其余的实参，当做参数信息传递给当前函数
>
> 如果执行call一个实参都没有传递，非严格模式下是让函数中的this指向window，严格模式下指向的是undefined

~~~js
window.name = 'WINDOW';
let obj = {name: 'OBJ'};
function fn(n,m) {
	console.log(this.name);
}
fn(10,20); //=>this:window  严格下是undefined
fn.call(obj); //=>this:obj  n/m=undefined
fn.call(obj,10,20); //=>this:obj  n=10 m=20
fn.call(10,20); //=>this:10  n=20  m=undefined

fn.call(); //=>this:window  严格下是undefined
fn.call(null); //=>this:window  严格下是null（第一个参数传递的是null/undefined/不传，非严格模式下this指向window，严格模式下传递的是谁this就是谁，不传this是undefined）

/* 
//=>我们的需求是想让FN执行的时候，方法中的THIS指向OBJ
obj.fn(); //=>Uncaught TypeError: obj.fn is not a function  
//因为此时obj中并没有fn这个属性

-------解决办法---------

obj.fn = fn;
obj.fn(); //=>this:obj  //=>'OBJ'
delete obj.fn;
*/
~~~

##### 我们自己基于原生JS实现内置的call方法

~~~js
// 内置CALL方法的实现
// ~ function () {
// 	/*
// 	 * call：改变函数中的THIS指向 
// 	 *   @params
// 	 *      context 可以不传递，传递必须是引用类型值（因为后面要给它加$fn的属性）  
// 	 */
// 	function call(context) {
// 		//this:sum 也就是当前要操作的这个函数实例
// 		context = context || window;
// 		let args = [], //=>除第一个参数外剩余传递的信息值
// 			result;
// 		for (let i = 1; i < arguments.length; i++) {
// 			args.push(arguments[i]);
// 		}
// 		context.$fn = this;
// 		result = context.$fn(...args); //=>args=[10,20] ...是ES6中的展开运算符，把数组中的每一项分别的展开传递给函数 //=>context.$fn(10,20)
// 		delete context.$fn;
// 		return result;
// 	}
// 	/* 扩展到内置类的原型上 */
// 	Function.prototype.call = call;
// }();

/* let obj = {
	name: 'OBJ'
};

function sum(n, m) {
	console.log(this);
	return n + m;
}
sum.call(1, 10, 20); */

~ function () {
	function call(context) {
		context = context || window;
		let args = [],
			result;
		for (let i = 1; i < arguments.length; i++) {
			args.push(arguments[i]);
		}
		context.$fn = this;
		result = context.$fn(...args);
		delete context.$fn;
		return result;
	}
	Function.prototype.call = call;
}();
~~~

![内置CALL方法的实现](C:\Users\左海之浅\Desktop\课程笔记\图片文件\内置CALL方法的实现.png)

##### 阿里面试题

~~~js
// 阿里的面试题
function fn1(){console.log(1);}
function fn2(){console.log(2);}
fn1.call(fn2);
fn1.call.call(fn2);
Function.prototype.call(fn1);
Function.prototype.call.call(fn1);
~~~

![内置CALL方法的实现2](C:\Users\左海之浅\Desktop\课程笔记\图片文件\内置CALL方法的实现2.png)

#### apply方法

> 和call一样，都是把函数执行，并且改变里面的this关键字的，唯一的区别就是传递给函数参数的方式不同
>
> - call是一个个传参
> - apply是按照数组传参

~~~js
let obj={name:'OBJ'};
let fn=function(n,m){
    console.log(this.name);
}
//=>让fn方法执行，让方法中的this变为obj，并且传递10/20
fn.call(obj,10,20);
fn.apply(obj,[10,20]);
~~~



#### bind方法

> 和call/apply一样，也是用来改变函数中的this关键字的，只不过基于bind改变this，当前方法并没有被执行，类似于预先改变this

~~~javascript
let obj={name:'OBJ'};
function fn(){
    console.log(this.name);
}
document.body.onclick=fn; //=>当事件触发,fn中的this:BODY

//=>点击BODY，让FN中的THIS指向OBJ
//document.body.onclick=fn.call(obj); //=>基于call/apply这样处理，不是把fn绑定给事件，而是把fn执行后的结果绑定给事件
document.body.onclick=function(){
    //this:BODY
    fn.call(obj);
}
document.body.onclick=fn.bind(obj); //=>bind的好处是：通过bind方法只是预先把fn中的this修改为obj，此时fn并没有执行呢，当点击事件触发才会执行fn（call/apply都是改变this的同时立即把方法执行） =>在IE6~8中不支持bind方法  预先做啥事情的思想被称为“柯理化函数”
~~~



#### 方法的应用

##### 获取数组中的最大值和最小值

~~~js
/* 获取数组中的最大值和最小值 */
let ary = [12, 24, 13, 8, 35, 15];

/* 解决方案一：先排序，第一项和最后一项就是我们需要的 */
/* ary.sort(function (a, b) {
	return a - b;
});
let min = ary[0];
let max = ary[ary.length - 1];
console.log(min, max); */

/* 解决方案二： Math.max/Math.min */
//=>Math.max/min要求我们传递的数据是一项项传递进来，获取一堆数中的最大最小，而不是获取一个数组中的最大最小
// let min = Math.min([12, 24, 13, 8, 35, 15]);
// console.log(min);//=>NaN
// let min = Math.min(12, 24, 13, 8, 35, 15);
// console.log(min); //=>8

//1.基于ES6的展开运算符
// let min = Math.min(...ary);
// console.log(min);

//2.利用apply来实现即可（this无所谓，主要是利用apply给函数传参，需要写成一个数组的特征）
// let min = Math.min.apply(Math, ary);
// console.log(min);

/* 解决方案三：假设法（假设第一个是最大的，让数组中的每一项分别和当前假设的值比较，如果比假设的值大，则把最大的值设为新的假设值，继续向后比较即可） */
let max = ary[0];
/* for (let i = 1; i < ary.length; i++) {
	let item = ary[i];
	item > max ? max = item : null;
} */
ary.forEach(item => {
	item > max ? max = item : null;
});
console.log(max); //=>35
~~~



### ES6的基础语法

#### ES6中的新语法规范

- let / const
- class 创建类
- import / export ：ES6 Module 模块的导入导出规范（JS中的模块化规范 AMD -> CMD -> CommonJS -> ES6 Module）
- Arrow Function 箭头函数
- 模板字符串
- 解构赋值
- “...” 拓展、展开、剩余运算符
- Promise / async / await
- for of循环
- Set / Map
- Array / Object ... 提供的新方法
- ......

#### let / const

> ES6中新增的用来创建变量和常量的

~~~js
let a = 12;
a = 13;
console.log(a); //=>13

const b = 12;
b = 13; //=>Uncaught TypeError: Assignment to constant variable. 基于CONST创建变量，变量存储的值不能被修改（常量）
console.log(b);
~~~

> let和var的区别

- let 不存在变量提升（当前作用域下，不能在let声明前使用变量）
- 同一个作用域中，let不允许重复声明
- let解决了typeof的一个暂时性死区问题
- 全局作用域中。使用let声明变量并没有给window加上对应的属性
- let会存在块作用域（处对象外的大括号都可以被看作块级私有作用域）

#### 箭头函数及THIS问题

> ES6中新增了创建函数的方式：“箭头函数”
>
> 真实项目中是箭头函数和FUNCTION这种普通函数混合使用

- 箭头函数简化了创建函数的代码

~~~js
//=>箭头函数的创建都是函数表达式方式（变量=函数），这种模式下，不存在变量提升，函数只能在创建完成后被执行（也就是创建的代码之后执行）
const fn=([形参])=>{
  //函数体	（return）  
};
fn([实参]);

//=>形参只有一个，小括号可以不加
const fn=n=>{};

//=>函数体中只有一句话，并且是return xxx的，可以省略大括号和return等
const fn=n=>n*10;

/*
function fn(n){
    return function(m){
        return m+(++n);
    }
}
*/
const fn=n=>m=>m+(++n);
~~~

- 箭头函数中没有arguments，但是可以基于剩余运算符获取实参集合，而且ES6中是支持给形参设置默认值的

~~~js
let obj = {};
let fn = (context = window, ...args) => {
	// console.log(arguments);//=>Uncaught ReferenceError: arguments is not defined 箭头函数中没有arguments
    // ...args：剩余运算符（把除第一项外的，其它传递的实参信息都存储到ARGS这个数组集合中）
	console.log(args);
};
fn(obj, 10, 20, 30); //=>context:obj  arg:[10,20,30]
fn(); //=>context:window  arg:[]
~~~

- 箭头函数中没有自己的this，它里面用到的this，都是自己所处上下文中的this（真实项目中，一旦涉及this问题，箭头函数慎用）

~~~js
window.name = "WINDOW";
let fn = n => {
	console.log(this.name);
};
let obj = {
	name: 'OBJ',
	fn: fn
};
// FN所处的执行上下文中的THIS是WINDOW
fn(10); //=>this:window
fn.call(obj, 10); //=>this:window 不是我们预期的OBJ
document.body.onclick = fn; //=>this:window 不是我们预期的BODY
obj.fn(10); //=>this:window
~~~

~~~js
let obj = {
	name: 'OBJ',
	fn: function () {
		//=>this:obj 普通函数是有自己的THIS的
		let f = () => {
			console.log(this);
		};
		f(); //=>this:obj
		return f;
	}
};
let f = obj.fn();
f(); //=>this:obj
~~~

`真实项目中的一个应用`

~~~js
let obj = {
	name: 'OBJ',
	fn: function () {
		//=>this:obj
		//=>原本期望的需求是：1S后把OBJ中的NAME改为'沅芷'
        setTimeout(() => {
			console.log(this); //=>OBJ
			this.name = '沅芷';
		}, 1000);
        
		/* setTimeout(function () {
			console.log(this);//=>WINODOW
			this.name = '沅芷';
		}, 1000); */

		/* let _this = this;//=>把需要的THIS提前用变量存储起来
		setTimeout(function () {
			_this.name = '沅芷'; //=>需要使用的时候拿出来用即可
		}, 1000); */
	}
};
obj.fn();
~~~

#### 解构赋值

> 让左侧出现和右侧值相同的结构，以此快速获取到我们需要的内容
>
> 真实项目中最常用的就是对数组和对象的解构赋值

~~~javascript
/* 数组的解构赋值 */
// let ary = [10, 20, 30, 40, 50];
/* let n = ary[0],
	m = ary[1],
	x = ary.slice(2); */
//=>...x拓展运算符：把剩下的内容存储到X中(X是个数组)，但是它只能出现在最后 
// let [n, m, ...x] = ary;
// console.log(n, m, x); //=>10 20 [30,40,50]
//=>如果没有这一项，我们可以基于等号赋值默认值
// let [n, , m, , , x = 0] = ary; 
// console.log(n, m, x); //=>10 30 0
//=>多维数组解构赋值
// let ary = [10, [20, 30, [40, 50]]];
// let [n, [, , [, m]]] = ary;
// console.log(n, m); //=>10 50

/* 对象的解构赋值 */
// let obj = {
// 	name: 'A',
// 	age: 79,
// 	sex: 'BOY',
// 	friends: ["B", "C", "D", "E"]
// };
//=>多维对象获取
// let {
// 	name,
// 	friends: [firstFriend]
// } = obj;
// console.log(name, firstFriend); //=>A B
//=>创建的变量要和对象的属性名一致（默认）
// let {
// 	name,
// 	nianling,
// 	sex
// } = obj;
// console.log(name, sex, nianling); //=>"A" "BOY" undefined
//=>冒号相当于给获取的结果设置了一个别名（变量名）：创建了一个叫做nianling的变量存储于了obj.age的值
// let {
// 	age: nianling
// } = obj;
// console.log(nianling); //=>79
//=>给获取的结果设置默认值（没有这个属性走的是默认值）
// let {
// 	height = "180CM"
// } = obj;
// console.log(height); //=>"180CM"

// 从服务器获取的DATA数据
let data = {
	"code": 0,
	"data": {
		"today": "2019-08-07",
		"data": [{
			"date": "2019-07-17",
			"number": "17",
			"weekday": "\u661f\u671f\u4e09"
		}, {
			"date": "2019-07-18",
			"number": "9",
			"weekday": "\u661f\u671f\u56db"
		}]
	},
	"version": "17917d337ccb7c4d34624b73efdfa0c0"
};
let {
	code,
	data: {
		today,
		data: calendarData
	}
} = data;
// console.log(code, today, calendarData);
// calendarData.forEach(item => {
// 	let {
// 		weekday,
// 		date
// 	} = item;
// 	console.log(weekday, date);
// });
~~~

#### "..."的作用

> - 拓展运算符（多用在解构赋值中）
> - 展开运算符（多用在传递实参中）
> - 剩余运算符（多用在接收实参中）

~~~js
//=>解构赋值
let [n,...m] = [12,23,34];
//n:12
//m:[23,34]

//=>传递实参
let ary=[12,23,13,24,10,25];
let min=Math.min(...ary);
//数组克隆（浅克隆）
let cloneAry=[...ary];
//对象克隆（浅克隆）
let obj={name:'Zero',age:16};
let cloneObj={...obj,sex:'girl',age:17};

//=>接收实参
let fn=(n,...arg)=>{
    //n:10
    //arg:[20,30]
};
fn(10,20,30);
~~~

#### class创建类

~~~javascript
//=>传统ES3/ES5中创建类的方法
function Fn(){
    this.x=100;
};
Fn.prototype.getX=function(){
    console.log(this.x);
};
var f1 = new Fn();
f1.getX();
//也可以把它当做普通函数执行
Fn();
//还可以把Fn当做普通的对象设置键值对
Fn.queryX=function(){};
Fn.queryX();
~~~

~~~javascript
//=>ES6中类的创建
class Fn{
    //等价于之间的构造函数体
    constructor(n,m){
        this.x=100;
    }
    //给实例设置的私有属性
    y=200

    //直接写的方法就是加在原型上的 === Fn.prototype.getX...
    getX(){
        console.log(this.x);
    }
    
    //前面设置static的：把当前Fn当做普通对象设置的键值对
    static queryX(){}
    static z=300
}
//也可以在外面单独这样写
Fn.prototype.y=200;
Fn.z=300;

let f = new Fn(10,20);
f.getX();
Fn.queryX();

Fn();//=>Uncaught TypeError: Class constructor Fn cannot be invoked without 'new'  =>class创建的类只能new执行，不能当做普通函数执行
~~~

#### ES6中的模板字符串

~~~js
let year = '2019',
    month = '08',
    day = '09';
//=>"你好，小伙伴！今天是2019年08月09日，今天天气很糟糕，马上就要下大雨了，呵呵呵~~~"
let res="你好，小伙伴！今天是"+year+"年"+month+"月"+day+"日，今天天气很糟糕，马上就要下大雨了，呵呵呵~~~";

let ID="box";
let html='<ul class="list clear" id="'+ID+'">';

//=>我们真实项目中会大量进行字符串拼接操作（尤其是需要动态绑定数据：把现有的HTML代码拼接成有数据的HTML字符串），传统的ES3语法模式下字符串拼接是一个非常苦逼的任务 ┭┮﹏┭┮
~~~

~~~js
let year = '2019',
    month = '08',
    day = '09';
//=>反引号（撇） TAB键上面的 （ES6模板字符串语法）
// ${} 模板字符串中书写JS表达式的方式（凡是有输出结果的都可以被称为JS表达式，一般都是一行搞定的）
let res=`你好，小伙伴！今天是${year}年${month}月${day}日，今天天气很糟糕，马上就要下大雨了，呵呵呵~~~`;

let ID="box";
let HTML=`<ul class="list clear" id="${ID}">
    <li><a href="javascript:;">
        <img src="img/1.jpg" alt="">
        <p></p>
        <span>￥3899</span>
    </a></li>
</ul>`;
//传统方式拼接一套HTML字符串，还需要一行行的处理，非常麻烦
~~~

#### THIS和面向对象的另一种深入理解

~~~js
function sum(){
   //ARGUMENTS:内置的实参集合（箭头函数中没有），不是数组是类数组（它不是数组的实例，不能直接使用数组的方法  arguments.__proto__===Object.prototype）
   let total=null;
   for(let i=0;i<arguments.length;i++){
      total+=arguments[i];
   }
   return total;
}
let total=sum(10,20,30,40);
~~~

~~~js
//=>ARG:存储传递的实参信息（数组）
//=>eval:把字符串转换为JS表达式执行
let sum=(...arg)=>eval(arg.join('+'));
let total=sum(10,20,30,40);
~~~

**如果ARGUMENTS是一个数组就好了~~~**

~~~js
~function(){
    function slice(n){
        //=>n:0 把数组克隆一份新的出来
        let newAry=[];
        for(let i=0;i<this.length;i++){
            newAry.push(this[i]);
        }
        return newAry;
    }
    Array.prototype.slice=slice;
}();
let ary=[10,20,30,40];
let newAry=ary.slice(0);//=>数组克隆
//--------------------------
function sum(){
   //=>把ARGUMENTS转换为数组：借用数组原型上的SLICE方法，只要让SLICE中的THIS指向ARGUMENTS，就相当于把ARGUMENTS转换为新数组
   //let arg=Array.prototype.slice.call(arguments,0);
   let arg=[].slice.call(arguments,0);
   //=>数组求和
   return eval(arg.join('+'));
}
let total=sum(10,20,30,40);
~~~

**不仅仅是一个方法可以这样调用，很多数组的方法，类数组都能用~~**

```javascript
function sum(){
   let total=null;
   [].forEach.call(arguments,item=>{
      total+=item; 
   });
   return total;
}
let total=sum(10,20,30,40);
```

## 二十一.UI组件库

> 有结构、样式、功能的库，里面提供很多开发中常用的组件，开发中直接把组件调取过来使用即可，无需从头开发（可能需要二次开发）
>
> - bootstrap（经常配合JQ一起用）：支持响应式布局开发（栅格系统）
> - vue : vue element / iview
> - react : antd
> - EasyUI / AmazeUI .....

https://www.bootcss.com/

> Bootstrap
>
> - v3.x
> - v4.x : https://v4.bootcss.com/

### 项目应用：商城排序

**HTML**

~~~HTML
<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title>商城排序DEMO</title>
	<!-- IMPORT CSS -->
	<link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css">
	<link rel="stylesheet" href="css/index.css">
</head>

<body>
	<!-- BT中建议所有内容都存放在CONTAINER容器中 -->
	<div class="container">
		<!-- NAV导航 -->
		<nav class="navbar navbar-expand-lg navbar-light bg-light">
			<a class="navbar-brand" href="javascript:;">商城排序</a>
			<div class="collapse navbar-collapse">
				<ul class="navbar-nav">
					<!-- DATA-PAI记录的是每个按钮应该按照哪个维度进行排序 -->
					<li class="nav-item" data-pai="data-time">
						<a class="nav-link" href="javascript:;">上架时间</a>
					</li>
					<li class="nav-item" data-pai="data-price">
						<a class="nav-link" href="javascript:;">价格</a>
					</li>
					<li class="nav-item" data-pai="data-hot">
						<a class="nav-link" href="javascript:;">热度</a>
					</li>
				</ul>
			</div>
		</nav>
		<!-- CARD-LIST商品列表 -->
		<div class="card-deck">
			<!-- <div class="card">
				<img class="card-img-top" src="img/1.jpg" alt="">
				<div class="card-body">
					<h6 class="card-title">HUAWEI Mate 10 4GB+64GB 全网通版（亮黑色）</h6>
					<p class="card-text">价格：￥5000</p>
					<p class="card-text">好评：100000</p>
					<p class="card-text"><small class="text-muted">上架时间：2019-08-07</small></p>
				</div>
			</div> -->

		</div>
	</div>

	<!-- IMPORT JS -->
	<script src="js/index.js"></script>
</body>

</html>
~~~

**reset.css**

~~~css
body,h1,h2,h3,h4,h5,h6,hr,p,blockquote,dl,dt,dd,ul,ol,li,button,input,textarea,th,td{margin:0;padding:0}body{font-size:12px;font-style:normal;font-family:"\5FAE\8F6F\96C5\9ED1",Helvetica,sans-serif}small{font-size:12px}h1{font-size:18px}h2{font-size:16px}h3{font-size:14px}h4,h5,h6{font-size:100%}ul,ol{list-style:none}a{text-decoration:none;background-color:transparent}a:hover,a:active{outline-width:0;text-decoration:none}table{border-collapse:collapse;border-spacing:0}hr{border:0;height:1px}img{border-style:none}img:not([src]){display:none}svg:not(:root){overflow:hidden}html{-webkit-touch-callout:none;-webkit-text-size-adjust:100%}input,textarea,button,a{-webkit-tap-highlight-color:rgba(0,0,0,0)}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]),video:not([controls]){display:none;height:0}progress{vertical-align:baseline}mark{background-color:#ff0;color:#000}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sub{bottom:-0.25em}sup{top:-0.5em}button,input,select,textarea{font-size:100%;outline:0}button,input{overflow:visible}button,select{text-transform:none}textarea{overflow:auto}button,html [type="button"],[type="reset"],[type="submit"]{-webkit-appearance:button}button::-moz-focus-inner,[type="button"]::-moz-focus-inner,[type="reset"]::-moz-focus-inner,[type="submit"]::-moz-focus-inner{border-style:none;padding:0}button:-moz-focusring,[type="button"]:-moz-focusring,[type="reset"]:-moz-focusring,[type="submit"]:-moz-focusring{outline:1px dotted ButtonText}[type="checkbox"],[type="radio"]{box-sizing:border-box;padding:0}[type="number"]::-webkit-inner-spin-button,[type="number"]::-webkit-outer-spin-button{height:auto}[type="search"]{-webkit-appearance:textfield;outline-offset:-2px}[type="search"]::-webkit-search-cancel-button,[type="search"]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}.clear:after{display:block;height:0;content:"";clear:both}
~~~

**CSS**

~~~css
/* BT中的样式不一定是最终自己想要的，那么我们就单独的修改即可
 *    如果自己改的样式不生效，很可能是权重优先级问题，此时最简单的方法就是设置"!important"可以使权重瞬间变为最大
 */
.container{
    padding: 0;
}

.card-deck{
    margin-top: 20px;
    /* 控制折行 */
    flex-wrap: wrap;
    margin-left: 0;
    margin-right: 0;
}

.card-deck .card{
    margin: 0 5px 10px 5px;
    flex: 0 0 218px;
}
~~~

**old JS (实现按价格升降序)**

~~~js
~ function () {
	/* 第一步：从服务器获取需要展示的数据，然后绑定在页面中 */
	// 1.基于AJAX获取服务器端数据，把数据存储到DATA中
	// 创建AJAX的实例
	let DATA = null,
		xhr = new XMLHttpRequest;
	// 打开一个请求的链接，基于GET请求和同步编程完成
	xhr.open('GET', 'json/product.json', false);
	// 监听服务器返回的状态信息（在HTTP状态码为200，请求状态为4的时候能拿到数据）
	xhr.onreadystatechange = function () {
		if (xhr.status === 200 && xhr.readyState === 4) {
			// 基于responseText获取响应回来的信息（JSON字符串）
			DATA = xhr.responseText;
		}
	};
	// 发送AJAX请求
	xhr.send();
	// 把获取的JSON字符串转换为对象
	DATA = JSON.parse(DATA);

	// 2.把获取的数据展示在页面中
	// 根据获取的DATA：DATA当中有多少项，我就动态创建出多少个CARD盒子（项目中都是基于字符串拼接的方式，把需要创建的CARD拼出来）
	let htmlStr = ``;
	DATA.forEach(item => {
		// ITEM是每一项（对象），包含需要展示的每一个产品的详细信息：我们需要拿出每一项信息来展示到页面中（拼到模板字符串中）
		// 基于解构赋值获取信息
		let {
			id,
			title,
			price,
			time,
			hot,
			img
		} = item;
		// 把需要的数据绑定在元素CARD的自定义属性DATA-XXX上（后期需要这些数据，直接基于自定义属性获取即可）
		htmlStr += `<div class="card" 
						data-price="${price}" 
						data-hot="${hot}" 
						data-time="${time}">
			<img class="card-img-top" src="${img}" alt="">
			<div class="card-body">
				<h6 class="card-title">${title}</h6>
				<p class="card-text">价格：￥${price}</p>
				<p class="card-text">好评：${hot}</p>
				<p class="card-text"><small class="text-muted">上架时间：${time}</small></p>
			</div>
		</div>`;
	});
	// 把拼接好的CARD字符串，放到页面指定容器中（card-deck）
	let cardDeck = document.querySelector('.card-deck');
	cardDeck.innerHTML = htmlStr;

	/* 第二步：点击价格/热度/上架时间，可以把内容按照升降序来排列 */
	// 1.想要操作谁先获取谁（三个排序按钮）和所有的CARD产品内容
	let navList = document.querySelectorAll('.navbar-nav li'),
		cardList = cardDeck.querySelectorAll('.card');

	// 2.先实现按照价格的升序排序
	// 设置DATA-TYPE自定义属性记录排序的状态（1升序 -1降序）
	navList[1]['data-type'] = -1;
	navList[1].onclick = function () {
		// 控制升降序切换
		this['data-type'] *= -1;
		// 把类数组转换为数组，目的是为了使用SORT进行排序
		cardList = Array.prototype.slice.call(cardList, 0);
		// 进行排序（按照每个产品中的价格进行升序）
		cardList.sort((next, cur) => {
			//=>NEXT/CUR存储的是每个元素对象（此时我们需要使用每个元素的价格：在数据绑定的时候，我们就把价格等信息绑定给当前元素的某个自定义属性，此时需要用的时候，直接基于自定义属性的方法获取到即可）
			cur = cur.getAttribute('data-price');
			next = next.getAttribute('data-price');
			return (next - cur) * this['data-type'];
		});
		// 以上只是让数据排好序，但是页面中的结构还没有改，我们需要按照当前的顺序，把每个CARD重新增加到容器中才可以
		cardList.forEach(item => {
			cardDeck.appendChild(item);
		});
	}
}();
~~~

**JS**

~~~js
~ function () {
	let _DATA = null;

	/*第一步：从服务器获取数据（AJAX）*/
	let xhr = new XMLHttpRequest;
	xhr.open('GET', 'json/product.json', false);
	xhr.onreadystatechange = function () {
		if (xhr.status === 200 && xhr.readyState === 4) {
			_DATA = xhr.responseText;
		}
	}
	xhr.send();
	_DATA = JSON.parse(_DATA); //=>_DATA：获取的都是JSON字符串，我们要让其变为对象

	//=>第二步：把获取的数据绑定在页面中
	let htmlStr = ``;
	_DATA.forEach(item => {
		let {
			title,
			price,
			time,
			hot,
			img
		} = item;
		htmlStr += `<div class="card" 
					data-price="${price}"
					data-time="${time}"
					data-hot="${hot}">
			<img class="card-img-top" src="${img}" alt="">
			<div class="card-body">
				<h6 class="card-title">${title}</h6>
				<p class="card-text">价格：￥${price}</p>
				<p class="card-text">好评：${hot}</p>
				<p class="card-text"><small class="text-muted">上架时间：${time}</small></p>
			</div>
		</div>`;
	});
	let cardDeck = document.querySelector('.card-deck');
	cardDeck.innerHTML = htmlStr;

	//=>第三步：点击实现升降序排序
	let navList = document.querySelectorAll('.navbar-nav li'),
		cardList = cardDeck.querySelectorAll('.card');

	//循环给所有的按钮绑定点击事件，点击的时候按照指定的规则排序
	for (let i = 0; i < navList.length; i++) {
		let item = navList[i];
		item['data-type'] = -1; //=>控制升降序
		item.onclick = function () {
			//=>点击当前的某个按钮，让其按照升降序切换，而其余的都应该回归原始-1
			[].forEach.call(navList, item => (item === this ? this['data-type'] *= -1 : item['data-type'] = -1));
			cardList = [].slice.call(cardList, 0);
			cardList.sort((next, cur) => {
				//获取当前按钮记录的排序方式 data-time / data-price / data-hot
				let pai = this.getAttribute('data-pai');
				cur = cur.getAttribute(pai);
				next = next.getAttribute(pai);
				if (pai === "data-time") {
					//获取的是日期数据：我们要把字符串中的“-”给去掉
					cur = cur.replace(/-/g, '');
					next = next.replace(/-/g, '');
				}
				return (next - cur) * this['data-type'];
			});
			cardList.forEach(item => cardDeck.appendChild(item));
		}
	}



	/*
		//给价格按钮绑定点击事件
		//给按钮设置一个自定义属性DATA-TYPE存储排序方式：-1降序 1升序
		navList[1]['data-type'] = -1;
		navList[1].onclick = function () {
			//控制升降序切换
			this['data-type'] *= -1;
			//把元素集合转换为数组，让其按照价格进行排序
			cardList = Array.prototype.slice.call(cardList, 0);
			cardList.sort((next, cur) => {
				//绑定数据的时候，把产品价格信息设置为元素的自定义属性，需要的时候获取
				cur = cur.getAttribute('data-price');
				next = next.getAttribute('data-price');
				return (next - cur) * this['data-type'];
			});
			//循环数组中的每一项,让其按照最新的顺序依次添加到页面中，完成页面排序
			cardList.forEach(item => cardDeck.appendChild(item));
		}

		navList[2]['data-type'] = -1;
		navList[2].onclick = function () {
			//控制升降序切换
			this['data-type'] *= -1;
			//把元素集合转换为数组，让其按照价格进行排序
			cardList = Array.prototype.slice.call(cardList, 0);
			cardList.sort((next, cur) => {
				//绑定数据的时候，把产品价格信息设置为元素的自定义属性，需要的时候获取
				cur = cur.getAttribute('data-hot');
				next = next.getAttribute('data-hot');
				return (next - cur) * this['data-type'];
			});
			//循环数组中的每一项,让其按照最新的顺序依次添加到页面中，完成页面排序
			cardList.forEach(item => cardDeck.appendChild(item));
		} */
}();
~~~

#### JSON格式的数据

> 我们基于AJAX等其它方式从服务器获取的数据结果一般都是：JSON格式或者XML格式
>
> - JSON格式的字符串
> - JSON格式的对象

~~~js
//=>普通对象
let obj = {
    name:"沅芷"
};
//=>JSON格式对象（其实就是把属性名用双引号包起来）
obj = {
    "name":"沅芷"
};
//=>JSON格式的字符串
let str = '{"name":"沅芷"}';
~~~

##### 把JSON格式的字符串转化为对象：window.JSON.parse

~~~js
let str = '{"name":"沅芷"}';
let obj = JSON.parse(str);
//=>{ name:"沅芷" }

//=>在IE低版本浏览器中，全局对象window中没有JSON这个对象，也就没有所谓的parse等方法了
obj=eval('('+str+')'); //=>基于eval可以实现，但是为了保证转换格式正确，我们需要把字符串用小括号包起来转换
~~~

##### 把对象转化为JSON格式字符串：JSON.stringify

~~~js
let obj = {
    name:"沅芷"
};
let str = JSON.stringify(obj); //=>'{"name":"沅芷"}'
~~~

#### 阻止a标签默认行为

~~~html
	<!-- A标签第一个作用：超链接 -->
	<!-- <a href="http://www.yuanzhililan.cn/">沅芷澧兰</a>
	<a href="http://www.yuanzhililan.cn/" target="_blank">沅芷澧兰		</a> -->

	<!-- A标签第二个作用：锚点定位 -->
	<!-- <a href="#box">哈哈</a>
	<div id="box">
		呵呵
	</div> -->

	<!-- A标签第三个作用：普通按钮 -->
	<!-- href="javascript:;" 阻止A标签的默认行为 -->
	<a href="javascript:;" id="link">我就是个按钮</a>
	<script>
		// JS阻止默认行为
		link.onclick = function (ev) {
			// ev.preventDefault();
			// 或
			// return false;
		}
	</script>
~~~

#### 关于sort排序的

~~~js
//=>把数组中的每一项按照AGE进行升序排列
//SORT中传递一个函数，函数中有A/B
//A当前项的后一项
//B当前项
//如果当前函数返回的是一个小于零的值，让A和B的位置互换，如果返回的是大于等于零的值，位置保持不变
let ary = [{
	id: 1,
	age: 25,
	name: '张三'
}, {
	id: 2,
	age: 32,
	name: '李四'
}, {
	id: 3,
	age: 23,
	name: '张五'
}];
// 按照NAME排序 : localeCompare能够进行字符串比较
/* ary.sort((a, b) => {
	return a.name.localeCompare(b.name);
}); */
// 按照AGE升序和降序
/* ary.sort((a, b) => {
	return a.age - b.age;
});
ary.sort((a, b) => {
	return (a.age - b.age) * -1;
}); */
console.log(ary);
~~~

#### DOM的映射机制

![DOM的映射机制](C:\Users\左海之浅\Desktop\课程笔记\图片文件\DOM的映射机制.png)



## 复习.面向对象（OOP）和THIS综合复习

### 一、OOP面向对象编程

> 在JS中面向类/实例进行程序设计，就是经典的面向对象编程
>
> - 类和实例的创建（构造函数模式）
> - prototype / __ proto __（原型和原型链）
> - 函数的三种角色
> - 基于内置类原型扩展方法，实现链式写法
> - 借用内置类原型上的方法，实现一些特殊的需求（例如：把类数组转换为数组）
> - 细小的知识点：instanceof / constructor / hasOwnProperty ...
> - 类的继承封装和多态
> - ......

#### 构造函数模式

~~~js
function Fn(n,m){
    let plus=n+m,
        minus=n-m;
    this.x=plus;
    this.y=minus;
    this.print=function(){
        console.log(this.x+this.y);
    }
}
let f1=new Fn(30,10);
f1.print();
console.log(f1.plus); //=>undefined
console.log(f1 instanceof Fn); //=>true

let f2=new Fn; //=>没有传递任何的实参
console.log(f1.print===f2.print); //=>false
/*
 * 构造函数执行
 * 1.开辟一个新的私有作用域
 * 2.形参赋值&变量提升
 * 3.浏览器在当前作用域中创建一个实例对象@A，并且让THIS指向它
 * 4.代码执行  this=>当前类的实例@A
 *   this.xxx=xxx都是给当前实例@A设置的私有属性
 *   除此之外的私有变量等和@A这个实例没有必然的关系
 * 5.即使我们不设置RETURN，浏览器也会默认把实例@A返回，而外面的f1/f2接收到的就是返回的实例，所以也说f1/f2是Fn这个类的实例（如果手动返回的是引用类型值，会以用户返回的为主，也就是返回的不再是Fn的实例，如果返回基本类型值，对原有的操作无影响）
 */

Fn(10,20);
window.print();
/*
 * 普通函数执行
 *  1.形成私有的栈内存（私有的作用域scope）
 *  2.形参赋值&变量提升 n=10 m=20
 *  3.代码执行 this=>window
 *  4.没有RETURN返回值
 */
~~~

#### 原型:prototype 和 原型链:__ proto __

- 每一个函数都自带一个属性：prototype，它的属性值是一个对象
- prototype这个对象中有一个默认的属性：constructor，储存函数本身
- 每一个对象都只带一个属性：__ proto __ ，属性值是所属类的prototype

  - 普通对象、数组、正则、日期等都是对象
  - 类的实例是对象 （基本数据类型值虽然是所属类实例，但不是对象）
  - prototype原型属性值也是对象
  - 函数本身也是一个对象

~~~js
function Fn() {
    this.x = 100;
    this.y = 200;
    this.getX = function () {
        console.log(this.x);
    }
}
Fn.prototype.getX = function () {
    console.log(this.x);
};
Fn.prototype.getY = function () {
    console.log(this.y);
};
let f1 = new Fn;
let f2 = new Fn;
console.log(f1.getX === f2.getX);
console.log(f1.getY === f2.getY);
console.log(f1.__proto__.getY === Fn.prototype.getY);
console.log(f1.__proto__.getX === f2.getX);
console.log(f1.getX === Fn.prototype.getX);
console.log(f1.constructor);
console.log(Fn.prototype.__proto__.constructor);
f1.getX(); //=>this:f1  =>console.log(f1.x)  =>100
f1.__proto__.getX(); //=>this:f1.__proto__  =>console.log(f1.__proto__.x)  =>undefined
f2.getY(); //=>this:f2
Fn.prototype.getY(); //=>this:Fn.prototype
~~~

![原型和原型链](C:\Users\左海之浅\Desktop\课程笔记\图片文件\原型和原型链.png)

#### 函数的三种角色

- 普通函数（闭包作用域、作用域链）
- 构造函数（类、实例、原型、原型链）
- 普通对象（键值对）

**三种角色之间没有必然的联系**

~~~js
//=>JS中运算符的优先级：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
function Foo() {
    getName = function () {
        console.log(1);
    };
    return this;
}
Foo.getName = function () {
    console.log(2);
};
Foo.prototype.getName = function () {
    console.log(3);
};
var getName = function () {
    console.log(4);
};
function getName() {
    console.log(5);
}
Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
~~~

![函数三种角色](C:\Users\左海之浅\Desktop\课程笔记\图片文件\函数三种角色.png)

#### 基于内置类原型扩展方法，实现链式写法

~~~javascript
let ary = [12,13,13,12,24,13,12];
//=>ary是Array数组类的实例，所以可以调取Array.prototype上的方法，sort方法中的this是ary，当前要排序的数组实例（底层理解：sort是内置方法，它可以实现排序，ary.sort(...)本意：ary先基于__proto__找到Array.prototype上的sort方法，并且把sort方法执行，方法中的this是ary，sort方法在执行的时候，会把this对应的数组进行排序处理）
ary.sort((a,b)=>a-b);

/*
//=>slice执行的时候，方法中的this是谁，就相当于把谁克隆成一份全新的数组出来
Array.prototype.slice=function(){
    //this:当前需要操作的这个数组
    let newAry=[];
    for(let i=0;i<this.length;i++){
        newAry.push(this[i]);
    }
    return newAry;
};
*/
let newAry = ary.slice(0);
newAry = Array.prototype.slice.call(ary,0);

function fn(){
    //=>arguments类数组集合（实参集合）：不是Array的实例，它就是一个对象而已，不能直接使用数组中的方法 （=>把类数组转换为数组）
    let ary = Array.prototype.slice.call(arguments,0);
    ary = [].slice.call(arguments,0);
    
    //=>借用数组原型上的FOREACH方法，实现给类数组进行循环（内置方法中的THIS是谁，其实当前方法就在操作谁）
    [].forEach.call(arguments,item=>{
        
    });
}
fn(10,20,30,40,50);
~~~

**内置方法很多，但是不一定完全够用，很多时候我们需要自己向内置类的原型上扩展方法来实现一些需求**

~~~js
~function(){
    function unique(){
        //注意:this是谁就给谁去重
        let temp={};
        for(let i=0;i<this.length;i++){
            let item=this[i];
            if(typeof temp[item]!=="undefined"){
                //this.splice(i,1);
                this[i]=this[this.length-1];
                this.length--;
                i--;
                continue;
            }
            temp[item]=item;
        }
        temp=null;
        //注意:返回的结果如果还是数组，则继续可以调取Array.prototype上的其它方法，实现“链式写法”
        return this;
    }
    //往内置类原型上扩展方法：为了防止不修改原有内置的方法，我们扩展的方法名要增加对应的前缀
    Array.prototype.myUnique = unique;
}();
let ary = [12,13,13,12,24,13,12];
ary.myUnique().reverse().push('A');
//Array.prototype.myUnique.call(ary);
~~~

### 二、THIS问题

> THIS函数执行的主体：谁执行的
>
> THIS 是谁和函数在哪执行和在哪定义都没关系，想要分清执行主体，记住以下规律即可

- 给元素的某个事件绑定方法，当事件触发方法执行的时候，方法中的this是当前元素本身
- 方法执行，看方法名前面是否有点，有点，点前面是谁，this就是谁；没有点this是window（JS在严格模式下，没有点this是undefined）
  - "use strict"开启严格模式
  - 自执行函数、回调函数等方法中的this一般是window
- 在构造函数执行过程中，构造函数体中的this是当前类的实例
- 使用call/apply/bind可以改变函数中的this指向
- es6箭头函数中没有自己的this，所用的this是继承上下文中的

~~~javascript
function fn(n,m){
    this.total=n+m;
}
let obj={name:'OBJ'};

fn(10,20); //=>this:window
//obj.fn(20,30); //=>报错：obj中没有fn属性
document.body.onclick=fn; //=>点击后FN中的this:BODY
document.body.onclick=function(){
   //=>this:BODY
   fn(30,40); //=>this:window  
};

fn.call(); //=>this:window 不传或者传递null/undefined都是
fn.call(obj,10,20); //=>this:obj
fn.apply(obj,[10,20]);//=>this:obj APPLY要求传递的参数是数组
document.body.onclick=fn.bind(obj,10,20); //=>BIND是预处理THIS，此时的FN还没有执行，只是把THIS改成了OBJ，点击BODY的时候才执行的 =>“柯理化函数”（预处理机制）
~~~

#### 构造函数中的this

~~~javascript
function Fn(){
    this.x=100;
    this.y=200;
}
Fn.prototype.sum=function(){
    console.log(this.x+this.y);
};
let f = new Fn; //=>Fn中的this:f 当前类的实例
f.sum(); //=>this:f
Fn.prototype.sum(); //=>this:Fn.prototype
f.__proto__.sum(); //=>this:f.__proto__
~~~

~~~JS
//=>ES6的写法
class Fn{
    constructor(){
        //=>this:当前Fn类的实例
        this.x=100;
    	this.y=200;
    }
    //=>直接写的方法就是放到原型上的
    sum(){console.log(this.x+this.y);}
    //=>STATIC修饰的都是把Fn当做普通对象设置的键值对
    static unique(){}
}
Fn.prototype.name='沅芷';
Fn.age=10;

let f = new Fn;
f.sum();
Fn.unique();
//Fn();//=>Uncaught TypeError: Class constructor Fn cannot be invoked without 'new'
~~~

#### 箭头函数中的this

~~~js
window.name='WINDOW';
let obj={
    name:'OBJ',
    fn:()=>{
        console.log(this.name);
    }
};
obj.fn();//=>this:window
obj.fn.call(obj);//=>this:window

//==================
document.body.onclick=function(){
    //=>this:BODY
    let _this=this;
    _this.count=0;
    
    /*setTimeout(function(){
        //=>this:window
        _this.count++;
    },1000);*/
    
    setTimeout(()=>{
        //=>this:没有自己的THIS，继承下上文中的，也就是BODY
        this.count++;
    },1000);
}
~~~



**关于this这块的问题：**

- 重写Function.prototype中内置call/apply方法（bind可以自己研究）
- fn1.call.call.call(fn2)...这道阿里面试题
- 获取数组中的最大值和最小值：Math.min.apply(Math,ary) ...

### 三、面试题

#### ES6中的新语法规范

- let / const
- class 创建类
- import / export ：ES6 Module 模块的导入导出规范（JS中的模块化规范 AMD -> CMD -> CommonJS -> ES6 Module）
- Arrow Function 箭头函数
- 模板字符串
- 解构赋值
- “...” 拓展、展开、剩余运算符
- Promise / async / await
- for of循环
- Set / Map
- Array / Object ... 提供的新方法
- ......

#### 数组去重

```javascript
/*===第一种===*/
~function(){
    function unique(){
        let obj={},
            _this=this;
        for(let i=0;i<_this.length;i++){
        	let item=_this[i];
            //in hasOwnProperty typeof ...
            if(obj.hasOwnProperty(item)){
                _this[i]=_this[_this.length-1];
                _this.length--;
                i--;
                continue;
            }
            obj[item]=item;
        }
        obj=null;
        return _this;
    }
    Array.prototype.myUnique=unique;
}();
let ary = [12,23,12,13,13,12,23,14,8];
ary.myUnique().sort((a,b)=>a-b);
```

```javascript
/*===第二种===*/
~function(){
    function unique(){
        let _this=this;
       	//=>首先基于new Set实现数组去重（结果是Set的实例）
        _this=new Set(_this);
        //=>再基于Array.from把类数组等变为数组
        _this=Array.from(_this);
        return _this;
    }
    Array.prototype.myUnique=unique;
}();
let ary = [12,23,12,13,13,12,23,14,8];
ary.myUnique().sort((a,b)=>a-b);
```

```javascript
/*===第三种（不推荐）===*/
~function(){
    function unique(){
        let _this=this;
       	for(let i=0;i<_this.length-1;i++){
            let item=_this[i],
                next=_this.slice(i+1);
            if(next.includes(item)){
                _this.splice(i,1);
                i--;
            }
        }
        return _this;
    }
    Array.prototype.myUnique=unique;
}();
let ary = [12,23,12,13,13,12,23,14,8];
ary.myUnique().sort((a,b)=>a-b);
```

**回去拓展更多的实现数组去重的办法**

#### QUERY-URL-PARAMS

> 用来解析URL地址中问号传参的信息

```javascript
~function(){
    /*
     * getParam:获取URL问号传参中某一个参数对应的值
     *   @params
     *      key:要获取值的属性名
     *   @return
     *      当前传递KEY对应的属性值
     * by yuanzhililan on 2019/08/12
     */
    function getParam(key){
        //1.先获取URL字符串中所有问号参数信息
        //验证是否存在问号,不存在无需处理
        let obj={},
            _this=this,
            askIn=_this.indexOf('?');
        if(askIn===-1) return;
        //获取问号后面的参数信息
        let link=document.createElement('a'),
            askText=null;
        link.href=_this;
        askText=link.search.substring(1);
        //把参数信息解析成为键值对的方式
        askText.split('&').forEach(item=>{
            let [key,value] = item.split('=');
            obj[key] = value;
        });
        //2.获取对应的属性值并返回
        return obj[key];
    }
    String.prototype.getParam=getParam;
}();
var url="locallhost?key1=val1&key2=val2&key3=val3";
console.log(url.getParam("key3")); //=>'val3'
```

#### 柯理化函数

```javascript
/*
function fn(x,y){
    return function(z){
        return x+y+z;
    }
}
*/
let fn=(x,y)=>z=>x+y+z;
let res = fn(1,2)(3);
console.log(res); //=>6  1+2+3
```

#### CALL、APPLY&BIND的重写

```javascript
~function(){
    function changeThis(context){
    	context=context||window;
        //let arg=[].slice.call(arguments,1);
        let arg=[],
            _this=this,
            result=null;
        for(let i=1;i<arguments.length;i++){
            arg.push(arguments[i]);
        }
        context.$fn=_this;
        result=context.$fn(...arg);
        delete context.$fn;
        return result;
	};
    Function.prototype.changeThis=changeThis;
}();

let obj = {name:'Alibaba',$fn:100};
function fn(x,y){
    this.total=x+y;
    return this;
}
let res = fn.changeThis(obj,100,200);
//res => {name:'Alibaba',total:300}
```

**基于ES6语法重构**

```javascript
~function(){
    /*生成随机函数名：时间戳的方式*/
    function queryRandomName(){
        let time=new Date().getTime();
        return '$yuanzhi'+time;
    }
    /*模拟CALL方法改变函数中的THIS*/
    function changeThis(context=window,...arg){
        let _this=this,
            result=null,
            ran=queryRandomName();
        context[ran]=_this;
        result=context[ran](...arg);
        delete context[ran];
        return result;
	};
    Function.prototype.changeThis=changeThis;
}();
```

**APPLY重写**

```javascript
~function(){
    /*生成随机函数名：时间戳的方式*/
    function queryRandomName(){
        let time=new Date().getTime();
        return '$yuanzhi'+time;
    }
    /*模拟CALL方法改变函数中的THIS*/
    function changeThis(context=window,arg=[]){
        let _this=this,
            result=null,
            ran=queryRandomName();
        context[ran]=_this;
        result=context[ran](...arg);
        delete context[ran];
        return result;
	};
    Function.prototype.changeThis=changeThis;
}();
let res = fn.changeThis(obj,[100,200]);
```

**bind重写**

~~~js
~function(){ 
    //=>bind方法在IE6~8中不兼容，接下来我们自己基于原生JS实现这个方法 
    function bind(context){ 
        context=context||window; 
        var _this = this, 
            outerArg=[].slice.call(arguments,1); 
        return function anonymous() { 
            var innerArg=[].slice.call(arguments,0);
            _this.apply(context, outerArg.concat(innerArg));
        } 
    };
    Function.prototype.bind=bind; 
}(); 
~~~

#### TO-ARRAY

```javascript
let utils = (function(){
    /*
     * toArray：转换为数组的方法
     *   @params
     *      不固定数量，不固定类型
     *   @return
     *      [Array] 返回的处理后的新数组
     * by yuanzhililan on 2019/08/12
     */
    /*
    function toArray(){
        /!*
        let arg=[];
        for(let i=0;i<arguments.length;i++){
            arg.push(arguments[i]);
        }
        return arg;
        *!/
        return Array.prototype.slice.call(arguments,0);
    }
    */
    //function toArray(...arg){
        //return arg;
    //}
    let toArray=(...arg)=>arg;
    return {
        toArray
    };
})();

let ary = utils.toArray(10,20,30);
//ary=[10,20,30]
ary = utils.toArray('A',10,20,30);
//ary=['A',10,20,30]
```

#### hasPubProperty

```javascript
~function(){
    /*
     * hasPubProperty:检测某个属性是否为对象的公有属性
     *   @params
     *     attr:要检测的属性名（字符串或者数字）
     *   @return 
     *     [Boolean] 检测的结果TRUE/FALSE
     * by yuanzhililan on 2019/08/12
     */
    function hasPubProperty(attr){
        if(typeof attr!=="string" && typeof attr!=="number") return false;
        return (attr in this) && !(this.hasOwnProperty(attr));
    }
   	Object.prototype.hasPubProperty=hasPubProperty;
}();

obj.hasPubProperty('name')
```

#### class重构

```javascript
function Modal(element){
    element=element||document;
	this.element=element;
}
Modal.prototype.show=function(){
	this.element.style.display='block';
}
Modal.prototype.hide=function(){
	this.element.style.display='none';
}
Modal.position={
	x:100,
	y:200
};
Modal.setPosition=function(x,y){
	this.position={x:x,y:y};
};
let m = new Model(document.body);
//以上代码基于ES6中的class和其它新语法进行重写

class Modal{
    constructor(element=document){
        this.element=element;
    }
    show(){
    	this.element.style.display='block';
	}
    hide(){
    	this.element.style.display='none';
	}
    static setPosition(x,y){
        this.position={x:x,y:y};
    }
}
Modal.position={x:100,y:200};
```

