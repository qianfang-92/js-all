<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
    /*
        复习昨天的内容：

        变量提升：
            在代码执行之前，会提前把带var和带function的变量提前声明
            带var 只声明不定义
            带function 既声明又定义；但是在判断句和循环句中的function是只声明 不定义的
            只提升等号左边的内容（这是说，连等的时候，只提升第一个）
            return后面的函数也不提升

            let const 不存在变量提升的 它们存在暂时性死区，在let const 声明之前，绝对不能够调用，绝对，就算外面的全局中有相同的var的变量，也不能够在函数里调用
        
        堆内存：用来存储引用数据类型
        栈内存：用来存储值类型（基本数据类型） 
                也用来提供代码的运行环境（作用域）
        
        作用域：scope 它是一个栈内存
            代码能够起作用的区域
            两大类：
                全局作用域：页面一打开就会形成一个全局作用域，整个页面只有一个全局作用域
                私有作用域：函数一执行就会形成一个私有作用域，同一个函数，执行几次就会形成几个私有作用域，私有作用域可以有多个
            es6新增的块级作用域：针对let const 存在的一种作用域，let const能够识别 可以理解为私有作用域

            全局变量：在全局声明的变量，我们称为全局变量
            私有变量：在私有作用域声明的变量，我们称为私有变量 
                     除此之外，形参也是私有变量
            
        作用域链：变量的查找机制  
                在某个私有作用域中，存在某个变量，那么这个变量的取值有一套规律，
                先在自己作用域中查找，如果不是自己作用域 里的变量，就向上级查看，找到即可，直到到window 如果还是没有，就会报错

        上级作用域：针对私有作用域而言，函数执行形成的一个私有作用域，那么，这个私有作用域的上级作用域是谁，由这个函数是在哪个作用域定义的有关，也就是说，这个函数在哪个作用域写的

        函数执行的过程：先开辟一个私有作用域，栈内存 ，然后形参赋值，变量提升，代码从上到下执行

        高阶函数：有几个return 就是几阶函数
    */
   var f = a =>b => c => a+b+c
</script>
</body>
</html>