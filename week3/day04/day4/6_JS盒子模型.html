<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
            *{
                margin: 0;
                padding: 0;
                list-style: none;
            }
            #box{
                width: 200px;
                height: 200px;
                padding: 20px;
                background: #ccc;
                border:10px solid red;
                margin: 30px auto;
                /* overflow: hidden */
            }
            main{
                position: relative;
                padding: 50px;
                background: blue;
                margin: 20px;
                border: 30px dashed salmon;
            }
            body{
                background: #eee;
            }
        </style>
</head>
<body>
        <main>
                <div id="box">
                        担负起把党中央决策部署和对人民政协工作要求落实下去、把海内外中华儿女智慧和力量凝聚起来的政治责任，为决胜全面建成小康社会、进而全面建设社会主义现代化强国作出贡献”。在中央政协工作会议暨庆祝中国人民政治协商会议成立70周年大会上，习近平总书记从实现中华民族伟大复兴的高度，对人民政协担负的政治责任提出明确要求，对于我们把党中央决策部署落实下去、把各方面智慧和力量凝聚起来具有重要指导意义，必将激励全党全国各族人民为实现中华民族伟大复兴中国梦而不懈奋斗。
                </div>
        </main>
</body>
</html>
<script>
    // client  offset  scroll  width height  left top
    // clientWidth    内容宽度 + 左右padding
    // offsetWidth    clientWidth + 左右 border
    // offsetTop      当前盒子的外边框到上级参照物的内边框的偏移量
    // offsetParent   上级参照物：有定位的上级（包含 父级，祖父，曾祖父...）元素，所有所有上级都没有定位， 则参照物就是 body
    // scroll 内容不溢出  等同于  client
    //        内容溢出时  没有设置overflow  值是内容宽高 + 上或左padding
    //        内容溢出时  有设置overflow时  值是内容宽高 + 上下或左右padding
    // scrollTop  卷去内容的高度
    // 13个属性 只有 scrollTop和scrollLeft时可以设置值的， 其他的都是只读属性

    // 封装一个offset方法：该方法 可以求出 当前元素到body的偏移量；
    offset(box)// {l: , t: }
    function offset(ele) {
        // ele 到 body 的偏移量
        let l = ele.offsetLeft, // ele到上级参照物的左偏移量
            t = ele.offsetTop;
        let temp = ele.offsetParent;// ele的上级参照物
        while(temp){
            l += temp.clientLeft + temp.offsetLeft;
            t += temp.clientTop + temp.offsetTop;
            temp = temp.offsetParent;
        }
        return {
            l,t
        }
    }





</script>