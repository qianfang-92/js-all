<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script src="../jquery-3.3.1.js"></script>
<script>

    /*
        promise 不仅它的executor函数的同步报错可以捕获到，也能捕获ajax的失败，所以这样写，它还是捕获到了失败，走失败的回调函数

        promise的状态有三个，pending resolved rejected 一旦它的状态从pending变为resolved或rejected状态，之后的成功或失败都不会被then或者catch捕获到了

        在then后面再写一个catch，如果是失败，那么这个失败会先被then捕获到，catch不能再捕获这个失败了

        不管成功还是失败，都要执行的代码，我们可以放在finally里面


        then catch finally 这三个方法是在promise原型上的，promise的实例可以调用到；

        Promise的executor函数是同步执行的，then  catch等里面的函数是异步执行的
    */
    let p = new Promise(function (res, rej) {
        setTimeout(()=>{
            console.log(eee)
        },2000)
        console.log(qqq)
    }).then(function (data) {
        console.log(1,data)
    }).catch((err)=>{
        console.log('2',err)
    })

    /*
        all  race  resolve  reject   在promise自己上面，不在原型上
        工作中的很多插件是promise封装的

        all:
            几个promise实例，把名字放在一个数组中，作为all的参数，只有数组中promise的实例都成功，才会走then的成功的回调函数，只要有一个失败，就会走对应的失败函数，后边的就不会被捕获到，
            工作中是一次性要发几个请求，而且这几个请求都要成功，这时需要用到all

        allSettled  
            不管res还是rej都会走then里的成功的回调函数

        race
            赛跑的意思，看谁先走完，先走完的那个是成功，就走成功，是失败就走失败

        resolve  reject 
            是为了返回一个成功或失败的实例
    */
</script>