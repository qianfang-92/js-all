<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
    /*
        变量提升：
            在代码执行之前，会提前把带var和带function的变量提前声明
            带var 只声明不定义
            带function既声明又定义  ；在大括号（判断句和循环句）里包着的function是只声明不定义
            只提升等号左边的部分（连等的时候，只提升第一个）；return后面的也不提升

            let和const是不存在变量提升的，但是有暂时性死区：在let和const声明之前绝对不能调用

        堆内存：用来存储引用数据类型
        栈内存：用来存储值类型（基本数据类型） 也用来提供代码的运行环境（作用域）
        
        作用域：scope  它是一个栈内存
            代码能够起作用的区域
            两大类：全局作用域：页面一打开就会形成一个全局作用域，只有一个全局作用域  
                    私有作用域：函数一执行就会形成一个私有作用域  （同一个函数执行两次就会形成两个私有作用域） ；私有作用域可以有多个
                es6新增 ：块级作用域 ： 针对let和const存在的一种作用域，可以理解为私有作用域

            全局变量 在全局声明的变量 我们称为全局变量
            私有变量 在私有作用域声明的变量 称为私有变量  除此，形参也是私有变量
        
        作用域链：变量的查找机制；在某个私有作用域中，存在某个变量，那么这个变量的取值，有一套规律，先在自己作用域中查找，若不是自己作用域的变量，          则再去上级作用域查找，找到即可。找不到 就一直查到window

        上级作用域：针对私有作用域来说的；函数执行形成一个私有作用域，那么这个私有作用域的上级作用域是谁，是由这个函数是在 哪个作用域 定义 决定的

        函数执行的过程：先开辟一个私有作用域(栈内存)，然后形参赋值 变量提升 代码从上到下执行

        高阶函数：
    */

    function f () {
        return function () {
            return function () {
                //有几个return就是几阶函数
            }
        }
    }
    fn()()()

    var f = a => b => c => a+b+c
    //这个式子也是高阶函数
    
</script>
</body>
</html>