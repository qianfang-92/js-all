<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
    //typeScript
    // 作用域 就是 代码能够起作用(能影响的)的区域

    //作用域分为 全局作用域 和 私有作用域
    //作用域其实就是一块 栈内存 

    // 堆内存是用来存储引用数据类型的
    //栈内存是用来存储值类型的  还有就是用来提供代码运行环境的

    /*
        全局作用域：页面一打开就会形成一个全局作用域，一个页面只有一个全局作用域
        私有作用域：在函数执行的时候，会形成一个私有的作用域；
        块级作用域：指的是 判断句 循环句  的大括号包起来的部分  es6里新增的
                    只有let 和const声明的变量能识别块级作用域，对于var来说，不存在块级作用域

        全局作用域中声明的变量 我们称为全局变量
        私有作用域中声明的变量 我们称为私有变量； 形参也是私有变量;

        上级作用域：
            函数执行时形成的那个私有作用域，一般都会存在一个上级作用域，私有作用域的上级作用域，跟这个函数在哪里执行没有关系，只跟函数在哪个作用域定义有关系
        
        私有作用域中的变量，有可能不是该私有作用域的私有变量，这时该变量对应的值就需要去上级作用域查找；若仍不是上级作用域的私有变量，那么就接着向上查找，直到找到  window 全局 的位置，若仍没有，就会报错  
        这种查找变量的机制，我们称为  作用域链

        函数执行时，先有形参赋值，再进行变量提升
    */
    // let a = 13;
    // function f () {
    //     // console.log(a); //这时发现a不是自己作用域的东西，所以向上级作用域中查看 ，所以此时这里输出 13
    //     console.log(b);
    //     a = 100;
    // }
    // // f ();
    // function f2 () {
    //     var b = 100;
    //     function f () {
    //     // console.log(a); //这时发现a不是自己作用域的东西，所以向上级作用域中查看 ，所以此时这里输出 13
    //     console.log(b);
    //     a = 100;
    //     }
    //     // f(); // 这时，f函数的声明位置还是在window 所以b还是没有在window里被声明，所以此时b还是会报错
    //     return f;
    // }
    // var f3 = f2(); // ->f函数
    // f3(); //->f3在全局作用域执行 但是f3 和f一样指向一个函数地址，这个函数仍然是在 f2 里声明的，所以 -->100


    // var a = 10;
    // if (1 < 2) {
    //     var a = 12;
    //     console.log(a); // 12
    // }
    // console.log(a); //12

    // var b = 10;
    // if (1 < 2) {
    //     let b = 12;
    //     console.log(b); // 12  let const 能识别块级作用域
    // }
    // console.log(b); //10  


    // var a = 12;
    // var b = 10;
    // function f () {
    //     console.log(a); //函数执行时，进行这个私有作用域里的代码，这时碰见var 又变量提升 这里的 a 就是undefined
    //     var a = 100; //这是一个私有作用域中声明的一个a,不是外面的a
    //     console.log(b);  //会报错，虽然let不能变量提升，但是let也会告诉系统 这个变量是私有变量，就不允许你向上查找b了，所以要记住 不管在全局还是私有，let 声明的变量就只能在声明之后用
    //     let b = 13;
    // }
    // f ();
    // console.log(a); //这是外面的a,没动，而且 它不能找它子级里面的a ，所以这里的a 是 12

    var a = 12;
    function f (a) {
        console.log(a);
        a = 100;  //给私有的a赋值   
        console.log(a);//100
    }
    f();
    console.log(a);

    // var a = b = 20;  这样写 相当于 var a = 20; b = 20  连等的除了第一个声明的变量，其他的变量没有经过var 没有变量提升  但是这时window.d也是有的，也就是说window下有d这个属性
    //var a = 10, b = 10;  这样写  相当于 var a = 10; var b = 10
    // 'a' in window :意思是window里的a属性

</script>
</body>
</html>